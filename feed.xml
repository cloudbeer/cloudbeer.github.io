<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.1">Jekyll</generator><link href="https://youbug.cn/feed.xml" rel="self" type="application/atom+xml" /><link href="https://youbug.cn/" rel="alternate" type="text/html" /><updated>2022-12-20T10:16:49+00:00</updated><id>https://youbug.cn/feed.xml</id><title type="html">YouBug</title><subtitle>分享，记录而已</subtitle><entry><title type="html">自动化构建多架构(amd, arm)镜像</title><link href="https://youbug.cn/2022/12/buildx-multi-arch-images.html" rel="alternate" type="text/html" title="自动化构建多架构(amd, arm)镜像" /><published>2022-12-20T09:40:33+00:00</published><updated>2022-12-20T09:40:33+00:00</updated><id>https://youbug.cn/2022/12/buildx-multi-arch-images</id><content type="html" xml:base="https://youbug.cn/2022/12/buildx-multi-arch-images.html"><![CDATA[<p>现在很多软件发行的 Docker 镜像都会支持多架构，Docker 官方也有教程教大家如何实现，并且提供了一个 buildx 插件方便大家实现。本文使用 Gitlab CI 试了一下此插件，主要命令是 <code class="language-plaintext highlighter-rouge">docker buildx build --platform...</code>。</p>

<h2 id="检查-docker-环境">检查 docker 环境</h2>

<p>检查官方的 docker 20 的镜像，运行 docker info 查看 Plugins：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker info
Client:
 Context:    default
 Debug Mode: <span class="nb">false
 </span>Plugins:
  buildx: Docker Buildx <span class="o">(</span>Docker Inc., v0.9.1<span class="o">)</span>
  compose: Docker Compose <span class="o">(</span>Docker Inc., v2.14.1<span class="o">)</span>
...
</code></pre></div></div>

<p>已经内置了 buildx 插件。</p>

<h2 id="gitlab-ci-脚本">Gitlab CI 脚本</h2>

<h3 id="构建到官方仓库-docker-hub">构建到官方仓库 docker hub</h3>

<p>下面的示例 build 了一个 arm64 + amd64 的裸 JDK。</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">dockerx</span><span class="pi">:</span>
  <span class="na">stage</span><span class="pi">:</span> <span class="s">test</span>
  <span class="na">image</span><span class="pi">:</span> <span class="s">docker:20</span>
  <span class="na">variables</span><span class="pi">:</span>
    <span class="na">DOCKER_DRIVER</span><span class="pi">:</span> <span class="s">overlay2</span>
    <span class="na">DOCKER_HOST</span><span class="pi">:</span> <span class="s">tcp://docker:2376</span>
    <span class="na">DOCKER_TLS_CERTDIR</span><span class="pi">:</span> <span class="s">/certs</span>
    <span class="na">DOCKER_TLS_VERIFY</span><span class="pi">:</span> <span class="m">1</span>
    <span class="na">DOCKER_CERT_PATH</span><span class="pi">:</span> <span class="s">/certs/client</span>
  <span class="na">services</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">docker:20-dind</span>
  <span class="na">before_script</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">until docker version &gt; /dev/null; do sleep 1; done</span>
    <span class="pi">-</span> <span class="s">echo "FROM amazoncorretto:11" &gt; Dockerfile</span>
    <span class="pi">-</span> <span class="s">docker context create xbuilder-ctx</span>
    <span class="pi">-</span> <span class="s">docker buildx create --name xbuilder --use xbuilder-ctx</span>
    <span class="pi">-</span> <span class="s">docker buildx use xbuilder</span>
  <span class="na">script</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">echo $DOCKER_PASS | docker login -u$DOCKER_USER --password-stdin</span>
    <span class="pi">-</span> <span class="s">docker buildx build --platform linux/arm64,linux/amd64 -t cloudbeer/$CI_PROJECT_NAME:$CI_COMMIT_SHORT_SHA --push .</span>

</code></pre></div></div>

<ul>
  <li>主要的命令为 <code class="language-plaintext highlighter-rouge">docker buildx build --platform linux/arm64,linux/amd64</code>，可以直接指定平台架构。</li>
  <li>在 19+ 版本的 docker 里，docker 生产的证书需要时间，为了安全起见，需要检测 docker 状态：<code class="language-plaintext highlighter-rouge">until docker version &gt; /dev/null; do sleep 1; done</code>，等他没问题再进行下一步操作，否则任务会中断。</li>
  <li><code class="language-plaintext highlighter-rouge">docker context, docker buildx create, docker buildx use</code> 这些解决了 “
ERROR: multiple platforms feature is currently not supported for docker driver.”, “Docker buildx - could not create a builder instance with TLS data loaded from environment” 这些个错误。</li>
  <li><code class="language-plaintext highlighter-rouge">docker buildx build... --push</code> 会直接把镜像构建结果推送到 docker bub。</li>
</ul>

<p>构建结果：<a href="https://hub.docker.com/r/cloudbeer/pure-ci/tags">https://hub.docker.com/r/cloudbeer/pure-ci/tags</a></p>

<p><img src="/assets/posts/devops/docker-hub-multi.png" alt="Buildx result" /></p>

<h3 id="推送到-aws-ecr">推送到 AWS ECR</h3>

<p>使用 AWS 的服务，一般离不开 aws cli，在本场景中，要么在 aws cli 镜像中安装 docker，要么在 docker 里安装 aws cli，下面是我的测试脚本，此脚本可以 run 到最后：</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">dockerx-ecr</span><span class="pi">:</span>
  <span class="na">stage</span><span class="pi">:</span> <span class="s">test</span>
  <span class="na">image</span><span class="pi">:</span> <span class="s">amazon/aws-cli</span>
  <span class="na">variables</span><span class="pi">:</span>
    <span class="na">DOCKER_DRIVER</span><span class="pi">:</span> <span class="s">overlay2</span>
    <span class="na">DOCKER_HOST</span><span class="pi">:</span> <span class="s">tcp://docker:2376</span>
    <span class="na">DOCKER_TLS_CERTDIR</span><span class="pi">:</span> <span class="s">/certs</span>
    <span class="na">DOCKER_TLS_VERIFY</span><span class="pi">:</span> <span class="m">1</span>
    <span class="na">DOCKER_CERT_PATH</span><span class="pi">:</span> <span class="s">/certs/client</span>
  <span class="na">services</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">docker:dind</span>
  <span class="na">before_script</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">amazon-linux-extras install docker</span>
    <span class="pi">-</span> <span class="s">mkdir -p ~/.docker/cli-plugins/</span>
    <span class="pi">-</span> <span class="s">until docker version &gt; /dev/null; do sleep 1; done</span>
    <span class="pi">-</span> <span class="s">docker container create --name buildx docker/buildx-bin sh</span>
    <span class="pi">-</span> <span class="s">docker cp buildx:/buildx ~/.docker/cli-plugins/docker-buildx</span>
    <span class="pi">-</span> <span class="s">echo "FROM amazoncorretto:11" &gt; Dockerfile</span>
    <span class="pi">-</span> <span class="s">docker context create xbuilder-ctx</span>
    <span class="pi">-</span> <span class="s">docker buildx create --name xbuilder --use xbuilder-ctx</span>
    <span class="pi">-</span> <span class="s">docker buildx use xbuilder</span>
  <span class="na">script</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">aws ecr get-login-password --region us-east-1 | docker login --username AWS --password-stdin $DOCKER_REGISTRY</span>
    <span class="pi">-</span> <span class="s">docker buildx build --platform linux/arm64,linux/amd64 -t $DOCKER_REGISTRY/$CI_PROJECT_NAME:$CI_COMMIT_SHORT_SHA --push .</span>
</code></pre></div></div>

<p>上面的脚本大部分都成功了，最后还是折了。下面是一些坑总结（吐槽模式开启）：</p>

<ul>
  <li>使用 官方 docker 镜像作为基础镜像构建，会发现 awscli v2 装不上， awscli v2 安装到 alpine 需要编译，不是简单加几个依赖包就行的，这个懒得折腾了。</li>
  <li>使用 pip 官方安装的 awscli v2 居然是在 docker 里运行的，这是在搞笑吗？我本来就是个 dind，套娃了啊。</li>
  <li>使用 aws-cli 镜像作为底包，<code class="language-plaintext highlighter-rouge">amazon-linux-extras install docker</code> 这个安装的 docker 居然把 plugins 都干掉了。干掉 compose 可以理解，为啥把 buildx 这么好的工具干掉了。</li>
  <li>安装 buildx 插件，可以直接从 buildx 镜像包中拷贝，命令是 <code class="language-plaintext highlighter-rouge">docker container create</code> 和 <code class="language-plaintext highlighter-rouge">docker cp</code>。</li>
  <li>使用 AWS ECR 别忘记要先建库。</li>
  <li>使用 AWS ECR 别忘记要先建库。</li>
  <li>使用 AWS ECR 别忘记要先建库。</li>
  <li><strong>我忘记了。</strong></li>
</ul>

<p>最终的部分 log 贴在下面：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>...
<span class="nv">$ </span>aws ecr get-login-password <span class="nt">--region</span> us-east-1 | docker login <span class="nt">--username</span> AWS <span class="nt">--password-stdin</span> <span class="nv">$DOCKER_REGISTRY</span>
Login Succeeded
<span class="c">#3 transferring context: 2B done</span>
<span class="c">#3 DONE 0.1s</span>
<span class="c">#4 [linux/arm64 internal] load metadata for docker.io/library/amazoncorretto:11</span>
<span class="c">#4 DONE 2.6s</span>
<span class="c">#5 [linux/amd64 internal] load metadata for docker.io/library/amazoncorretto:11</span>
<span class="c">#5 DONE 2.6s</span>
...
<span class="c">#6 [linux/amd64 1/1] FROM docker.io/library/amazoncorretto:11@sha256:6962bc64de2b612c2a760299956853762cfcee538b1b6b55706661426546936c</span>
<span class="c">#6 DONE 0.1s</span>
<span class="c">#8 exporting to image</span>
<span class="c">#8 exporting layers done</span>
<span class="c">#8 exporting manifest sha256:3dd903be615ce4c36321b161806bc061a567079a2947ec658cdcd14d1c114235 0.0s done</span>
<span class="c">#8 exporting config sha256:8b9bb2aca3d28e14fa06412d152fd4ce6c7a55f1554bec3c71ce4a4410060af3</span>
<span class="c">#8 exporting config sha256:8b9bb2aca3d28e14fa06412d152fd4ce6c7a55f1554bec3c71ce4a4410060af3 0.0s done</span>
<span class="c">#8 exporting manifest sha256:4218135aa38e8522e988b60392190cd7bfc1715cedb3f301f82cec43fee383e2 0.0s done</span>
<span class="c">#8 exporting config sha256:de3379d966e1b03cf4c7f3c6db803f459cf1c3e887fbe2c10af9ce0c72a6f406 0.0s done</span>
<span class="c">#8 exporting manifest list sha256:dc0282c4166a58f7b8298e5061a00c02c6bce6e358000b479e49e6d73cf57b34 0.0s done</span>
<span class="c">#8 pushing layers</span>
<span class="c">#8 ...</span>
<span class="c">#9 [auth] sharing credentials for [MASKED].dkr.ecr.us-east-1.amazonaws.com</span>
<span class="c">#9 DONE 0.0s</span>
<span class="c">#8 exporting to image</span>
<span class="c">#8 ...</span>
<span class="c">#7 [linux/amd64 1/1] FROM docker.io/library/amazoncorretto:11@sha256:6962bc64de2b612c2a760299956853762cfcee538b1b6b55706661426546936c</span>
<span class="c">#7 sha256:74c4a50287c9345fabef12ad41b61e3450e3400fbe99f5d48281ceb781041ae3 147.75MB / 147.75MB 2.6s done</span>
<span class="c">#7 sha256:5b4a36b5b78f93a5f470cf722b313bb32cddb0f8e0fa0db348059b5c0881b04f 62.33MB / 62.33MB 1.0s done</span>
<span class="c">#7 DONE 2.9s</span>
<span class="c">#6 [linux/arm64 1/1] FROM docker.io/library/amazoncorretto:11@sha256:6962bc64de2b612c2a760299956853762cfcee538b1b6b55706661426546936c</span>
<span class="c">#6 sha256:c0aade9a94f7c23d8fc79b4c11ce14d37b8569a6fec3017a295169ff500ec8d8 144.91MB / 144.91MB 2.9s</span>
<span class="c">#6 sha256:6cbfee25f0741b3d3f4d2474d904a200cd8404a01aa17813bf3fc3d4ebb551a4 63.96MB / 63.96MB 1.8s done</span>
<span class="c">#6 sha256:c0aade9a94f7c23d8fc79b4c11ce14d37b8569a6fec3017a295169ff500ec8d8 144.91MB / 144.91MB 3.0s done</span>
<span class="c">#6 DONE 3.1s</span>
<span class="c">#8 exporting to image</span>
<span class="c">#8 pushing layers 17.6s done</span>
<span class="c">#8 pushing manifest for [MASKED].dkr.ecr.us-east-1.amazonaws.com/pure-ci:1ac460d1@sha256:dc0282c4166a58f7b8298e5061a00c02c6bce6e358000b479e49e6d73cf57b34</span>
<span class="c">#8 pushing manifest for [MASKED].dkr.ecr.us-east-1.amazonaws.com/pure-ci:1ac460d1@sha256:dc0282c4166a58f7b8298e5061a00c02c6bce6e358000b479e49e6d73cf57b34 2.2s done</span>
<span class="c">#8 DONE 19.8s</span>
Job succeeded
</code></pre></div></div>

<h2 id="不是本文的总结">不是本文的总结</h2>

<ul>
  <li>使用 docker-buildx 会直接使用相应架构的底层依赖镜像，如果使用这种方法，您不能将一个有架构依赖的可执行文件直接拷贝构建镜像，否则会出现底层包和业务包对不上的问题。</li>
  <li>可以将构建过程放到 Dockerfile 里面去，Docker 有完整的多阶段构建的模式来生产您的镜像（如 go 语言）。</li>
  <li>对于脚本类型的语言，完全可以用这种方式构建，依赖包安装也应该在 Dockerfile 中进行。</li>
  <li>Java 的普通运行包可以使用直接拷贝的方式，X86 环境下构建的 jar 包可以直接运行在 ARM 的 jdk 中。</li>
  <li>Dockerfile 的底包也应该是多架构的，请不要强制指定具体的 sha256 值。</li>
</ul>]]></content><author><name>啤酒云</name></author><category term="devops," /><category term="container," /><category term="tucao," /><category term="gitlab" /><summary type="html"><![CDATA[现在很多软件发行的 Docker 镜像都会支持多架构，Docker 官方也有教程教大家如何实现，并且提供了一个 buildx 插件方便大家实现。本文使用 Gitlab CI 试了一下此插件，主要命令是 docker buildx build --platform...。]]></summary></entry><entry><title type="html">在 AWS 构建应用 (Gitlab CI) 最便宜的姿势</title><link href="https://youbug.cn/2022/12/the-cheapest-way-to-ci-cn.html" rel="alternate" type="text/html" title="在 AWS 构建应用 (Gitlab CI) 最便宜的姿势" /><published>2022-12-19T03:40:33+00:00</published><updated>2022-12-19T03:40:33+00:00</updated><id>https://youbug.cn/2022/12/the-cheapest-way-to-ci-cn</id><content type="html" xml:base="https://youbug.cn/2022/12/the-cheapest-way-to-ci-cn.html"><![CDATA[<p>Graviton 在 AWS 是性价比最高的（最高节约 40%），而 Spot 实例适合任务类型的负载，最高能有 90% 的节省。而 Gitlab Runner 可以轻松将构建任务调度到这种类型的节点上。</p>

<h2 id="安装-gitlab-runner">安装 Gitlab runner</h2>

<p>首先，我们需要为 Gitlab runner 打一个标签。这里我设置了标签为 arm。稍后我们会将任务调度到这个 runner。</p>

<p>下面是 CDK 代码:</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">cluster</span><span class="p">.</span><span class="nx">addHelmChart</span><span class="p">(</span><span class="dl">"</span><span class="s2">arm-runner</span><span class="dl">"</span><span class="p">,</span> <span class="p">{</span>
  <span class="na">chart</span><span class="p">:</span> <span class="dl">"</span><span class="s2">gitlab-runner</span><span class="dl">"</span><span class="p">,</span>
  <span class="na">repository</span><span class="p">:</span> <span class="dl">"</span><span class="s2">http://charts.gitlab.io/</span><span class="dl">"</span><span class="p">,</span>
  <span class="na">version</span><span class="p">:</span> <span class="dl">"</span><span class="s2">0.48.0</span><span class="dl">"</span><span class="p">,</span>
  <span class="na">namespace</span><span class="p">:</span> <span class="dl">"</span><span class="s2">gitlab</span><span class="dl">"</span><span class="p">,</span>
  <span class="na">release</span><span class="p">:</span> <span class="dl">"</span><span class="s2">arm-runner</span><span class="dl">"</span><span class="p">,</span>
  <span class="na">createNamespace</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
  <span class="na">values</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">runnerRegistrationToken</span><span class="p">:</span> <span class="dl">"</span><span class="s2">&lt;your-runner-token&gt;</span><span class="dl">"</span><span class="p">,</span>
    <span class="na">gitlabUrl</span><span class="p">:</span> <span class="dl">"</span><span class="s2">&lt;your-gitlab-url&gt;</span><span class="dl">"</span><span class="p">,</span>
    <span class="na">privileged</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
    <span class="na">rbac</span><span class="p">:</span> <span class="p">{</span>
      <span class="na">create</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
      <span class="na">rules</span><span class="p">:</span> <span class="p">[</span>
        <span class="p">{</span>
          <span class="na">apiGroups</span><span class="p">:</span> <span class="p">[</span><span class="dl">""</span><span class="p">],</span>
          <span class="na">resources</span><span class="p">:</span> <span class="p">[</span><span class="dl">"</span><span class="s2">pods</span><span class="dl">"</span><span class="p">],</span>
          <span class="na">verbs</span><span class="p">:</span> <span class="p">[</span><span class="dl">"</span><span class="s2">list</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">get</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">create</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">watch</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">delete</span><span class="dl">"</span><span class="p">],</span>
        <span class="p">},</span>
        <span class="p">{</span>
          <span class="na">apiGroups</span><span class="p">:</span> <span class="p">[</span><span class="dl">""</span><span class="p">],</span>
          <span class="na">resources</span><span class="p">:</span> <span class="p">[</span><span class="dl">"</span><span class="s2">pods/exec</span><span class="dl">"</span><span class="p">],</span>
          <span class="na">verbs</span><span class="p">:</span> <span class="p">[</span><span class="dl">"</span><span class="s2">create</span><span class="dl">"</span><span class="p">],</span>
        <span class="p">},</span>
        <span class="p">{</span>
          <span class="na">apiGroups</span><span class="p">:</span> <span class="p">[</span><span class="dl">""</span><span class="p">],</span>
          <span class="na">resources</span><span class="p">:</span> <span class="p">[</span><span class="dl">"</span><span class="s2">pods/log</span><span class="dl">"</span><span class="p">],</span>
          <span class="na">verbs</span><span class="p">:</span> <span class="p">[</span><span class="dl">"</span><span class="s2">get</span><span class="dl">"</span><span class="p">],</span>
        <span class="p">},</span>
        <span class="p">{</span>
          <span class="na">apiGroups</span><span class="p">:</span> <span class="p">[</span><span class="dl">""</span><span class="p">],</span>
          <span class="na">resources</span><span class="p">:</span> <span class="p">[</span><span class="dl">"</span><span class="s2">pods/attach</span><span class="dl">"</span><span class="p">],</span>
          <span class="na">verbs</span><span class="p">:</span> <span class="p">[</span><span class="dl">"</span><span class="s2">list</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">get</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">create</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">update</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">delete</span><span class="dl">"</span><span class="p">],</span>
        <span class="p">},</span>
        <span class="p">{</span>
          <span class="na">apiGroups</span><span class="p">:</span> <span class="p">[</span><span class="dl">""</span><span class="p">],</span>
          <span class="na">resources</span><span class="p">:</span> <span class="p">[</span><span class="dl">"</span><span class="s2">secrets</span><span class="dl">"</span><span class="p">],</span>
          <span class="na">verbs</span><span class="p">:</span> <span class="p">[</span><span class="dl">"</span><span class="s2">list</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">get</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">create</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">update</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">delete</span><span class="dl">"</span><span class="p">],</span>
        <span class="p">},</span>
        <span class="p">{</span>
          <span class="na">apiGroups</span><span class="p">:</span> <span class="p">[</span><span class="dl">""</span><span class="p">],</span>
          <span class="na">resources</span><span class="p">:</span> <span class="p">[</span><span class="dl">"</span><span class="s2">configmaps</span><span class="dl">"</span><span class="p">],</span>
          <span class="na">verbs</span><span class="p">:</span> <span class="p">[</span><span class="dl">"</span><span class="s2">list</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">get</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">create</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">update</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">delete</span><span class="dl">"</span><span class="p">],</span>
        <span class="p">}</span>
      <span class="p">]</span>
    <span class="p">},</span>
    <span class="na">runners</span><span class="p">:</span> <span class="p">{</span>
      <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">arm-runner</span><span class="dl">"</span><span class="p">,</span>
      <span class="na">tags</span><span class="p">:</span> <span class="dl">"</span><span class="s2">arm, mass</span><span class="dl">"</span><span class="p">,</span>
      <span class="na">runUntagged</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
      <span class="na">helpers</span><span class="p">:</span> <span class="p">{</span>
        <span class="na">image</span><span class="p">:</span> <span class="dl">"</span><span class="s2">gitlab/gitlab-runner-helper:arm64-v14.10.2</span><span class="dl">"</span>
      <span class="p">},</span>
      <span class="na">config</span><span class="p">:</span> <span class="s2">`
    [[runners]]
    name = "arm-runner"
    environment = ["FF_USE_LEGACY_KUBERNETES_EXECUTION_STRATEGY=true"]
    executor = "kubernetes"
    [runners.kubernetes]
      image = "ubuntu:22.04"
      privileged = true
    [[runners.kubernetes.volumes.empty_dir]]
      name = "docker-certs"
      mount_path = "/certs/client"
      medium = "Memory"
    [[runners.kubernetes.volumes.empty_dir]]
      name = "dind-storage"
      mount_path = "/var/lib/docker"
    [[runners.kubernetes.volumes.host_path]]
      name = "hostpath-modules"
      mount_path = "/lib/modules"
      read_only = true
      host_path = "/lib/modules"
    [[runners.kubernetes.volumes.host_path]]
      name = "hostpath-hosts"
      mount_path = "/etc/hosts"
      read_only = true
      host_path = "/etc/hosts"
    [[runners.kubernetes.volumes.host_path]]
      name = "hostpath-cgroup"
      mount_path = "/sys/fs/cgroup"
      host_path = "/sys/fs/cgroup"
    [runners.kubernetes.node_selector]
      "karpenter-arch" = "arm64" 
    `</span>
    <span class="p">},</span>
  <span class="p">}</span>
<span class="p">});</span>
</code></pre></div></div>

<p>配置中需要着重关注以下:</p>

<ul>
  <li>在 ARM 环境下，需要指定 gitlab-runner-helper 的镜像，因为 这个镜像是单架构的，而默认的图样使的是 X86 的镜像。这个镜像会作为 构建任务的 sidecar 运行。</li>
  <li><code class="language-plaintext highlighter-rouge">FF_USE_LEGACY_KUBERNETES_EXECUTION_STRATEGY</code> 必须设置为 true 才能调度 pod 任务。</li>
  <li>配置中 <code class="language-plaintext highlighter-rouge">[runners.kubernetes.node_selector]</code> 是为 K8S 调度做准备的，此处表示后续的构建任务会调度到相应 tag 的 node 节点。</li>
</ul>

<h2 id="kapennter-节点池">Kapennter 节点池</h2>

<p><a href="https://karpenter.sh/">Karpenter</a>  是 AWS 最新的节点伸缩工具，非常好用。</p>

<p>Kapennter 的安装和入门就不做过多说明了。直接看代码：</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">karpenter.sh/v1alpha5</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Provisioner</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">arm-builder</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">requirements</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="na">key</span><span class="pi">:</span> <span class="s2">"</span><span class="s">karpenter.k8s.aws/instance-category"</span>
      <span class="na">operator</span><span class="pi">:</span> <span class="s">In</span>
      <span class="na">values</span><span class="pi">:</span> <span class="pi">[</span><span class="s2">"</span><span class="s">c"</span><span class="pi">,</span> <span class="s2">"</span><span class="s">m"</span><span class="pi">,</span> <span class="s2">"</span><span class="s">r"</span><span class="pi">]</span>
    <span class="pi">-</span> <span class="na">key</span><span class="pi">:</span> <span class="s">karpenter.sh/capacity-type</span>
      <span class="na">operator</span><span class="pi">:</span> <span class="s">In</span>
      <span class="na">values</span><span class="pi">:</span> <span class="pi">[</span><span class="s2">"</span><span class="s">spot"</span><span class="pi">]</span>
    <span class="pi">-</span> <span class="na">key</span><span class="pi">:</span> <span class="s2">"</span><span class="s">kubernetes.io/arch"</span>
      <span class="na">operator</span><span class="pi">:</span> <span class="s">In</span>
      <span class="na">values</span><span class="pi">:</span> <span class="pi">[</span><span class="s2">"</span><span class="s">arm64"</span><span class="pi">]</span>
  <span class="na">limits</span><span class="pi">:</span>
    <span class="na">resources</span><span class="pi">:</span>
      <span class="na">cpu</span><span class="pi">:</span> <span class="m">1000</span>
  <span class="na">labels</span><span class="pi">:</span>
    <span class="na">karpenter-arch</span><span class="pi">:</span> <span class="s">arm64</span>
  <span class="na">providerRef</span><span class="pi">:</span>
    <span class="na">name</span><span class="pi">:</span> <span class="s">default</span>
  <span class="na">ttlSecondsAfterEmpty</span><span class="pi">:</span> <span class="m">30</span>

<span class="nn">---</span>
<span class="na">apiVersion</span><span class="pi">:</span> <span class="s">karpenter.k8s.aws/v1alpha1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">AWSNodeTemplate</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">default</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">amiFamily</span><span class="pi">:</span> <span class="s">Bottlerocket</span>
  <span class="na">subnetSelector</span><span class="pi">:</span>
    <span class="s2">"</span><span class="s">aws:cloudformation:stack-name"</span><span class="err">:</span> <span class="s">gitlab</span>
    <span class="s">"aws-cdk:subnet-type": Private</span>
  <span class="na">securityGroupSelector</span><span class="pi">:</span>
    <span class="s2">"</span><span class="s">kubernetes.io/cluster/gitlab"</span><span class="err">:</span> <span class="s">owned</span>

</code></pre></div></div>

<p>代码说明:</p>

<ul>
  <li>创建了节点池(Provisioner)，可以指定节点的机型范围，CPU 类型，付费类型等。指定 arm 就可以选择 Graviton 机型，指定 spot 可以只购买竞价实例。</li>
  <li>这里建议使用 Bottlerocket 作为 node 的操作系统，使用 Amazon Linux 会抛出一个无法解析 git 仓库的地址的错误。</li>
</ul>

<h2 id="gitlab-ci-配置">Gitlab CI 配置</h2>

<p>现在需要将构建任务调度到这个 runner 上。</p>

<p>下面是 .gitlab-ci.yml 的示例：</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">stages</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="s">Build</span>

<span class="na">frontend-build</span><span class="pi">:</span>
  <span class="na">stage</span><span class="pi">:</span> <span class="s">Build</span>
  <span class="na">image</span><span class="pi">:</span> <span class="s">node:16.16.0-alpine</span>
  <span class="na">tags</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">arm</span>
  <span class="na">script</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">npm install</span>
    <span class="pi">-</span> <span class="s">npm run build</span>
  <span class="na">artifacts</span><span class="pi">:</span>
    <span class="na">paths</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">build/</span>
</code></pre></div></div>

<p>上面的代码很简单，只需要给构建任务指定 tags 标签即可</p>

<h2 id="总结">总结</h2>

<p>通过以上的三段配置，整体的 CI 流程如下：</p>

<p>触发 Gitlab 构建 -&gt; 寻找有 arm 标记的 runner -&gt; 启动构建任务(pod) -&gt; 寻找 <code class="language-plaintext highlighter-rouge">karpenter-arch: arm64</code> 的节点 -&gt; 没有符合条件的节点，pod pending -&gt; Karpenter 购买 arm + spot 节点 -&gt; 构建任务开始调度成功 -&gt; 执行构建任务 -&gt; 任务结束，释放 node 节点。</p>

<p>如图：</p>

<p><img src="/assets/posts/devops/gitlab-ci-karpenter.png" alt="Gitlab CI with karpenter" /></p>

<p>Karpenter 会购买最便宜的机型，全新节点的购买时间约 1 分 30 秒。</p>]]></content><author><name>啤酒云</name></author><category term="aws," /><category term="gitlab," /><category term="devops," /><category term="container" /><summary type="html"><![CDATA[Graviton 在 AWS 是性价比最高的（最高节约 40%），而 Spot 实例适合任务类型的负载，最高能有 90% 的节省。而 Gitlab Runner 可以轻松将构建任务调度到这种类型的节点上。]]></summary></entry><entry><title type="html">The cheapest way to build applications (Gitlab CI) on AWS</title><link href="https://youbug.cn/2022/12/the-cheapest-way-to-ci-en.html" rel="alternate" type="text/html" title="The cheapest way to build applications (Gitlab CI) on AWS" /><published>2022-12-18T12:59:33+00:00</published><updated>2022-12-18T12:59:33+00:00</updated><id>https://youbug.cn/2022/12/the-cheapest-way-to-ci-en</id><content type="html" xml:base="https://youbug.cn/2022/12/the-cheapest-way-to-ci-en.html"><![CDATA[<p>Graviton (ARM) is the most cost-effective in AWS (up to 40% savings), while Spot instances are suitable for task-type workloads and can save up to 90%. Gitlab Runner can easily schedule build tasks to Graviton + Spot instances.</p>

<h2 id="config-gitlab-runner">Config Gitlab runner</h2>

<p>First, we need to tag the Gitlab runner. Here I set the tag to arm. Later we will schedule the task to the runner.</p>

<p>Here is the CDK code:</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">cluster</span><span class="p">.</span><span class="nx">addHelmChart</span><span class="p">(</span><span class="dl">"</span><span class="s2">arm-runner</span><span class="dl">"</span><span class="p">,</span> <span class="p">{</span>
  <span class="na">chart</span><span class="p">:</span> <span class="dl">"</span><span class="s2">gitlab-runner</span><span class="dl">"</span><span class="p">,</span>
  <span class="na">repository</span><span class="p">:</span> <span class="dl">"</span><span class="s2">http://charts.gitlab.io/</span><span class="dl">"</span><span class="p">,</span>
  <span class="na">version</span><span class="p">:</span> <span class="dl">"</span><span class="s2">0.48.0</span><span class="dl">"</span><span class="p">,</span>
  <span class="na">namespace</span><span class="p">:</span> <span class="dl">"</span><span class="s2">gitlab</span><span class="dl">"</span><span class="p">,</span>
  <span class="na">release</span><span class="p">:</span> <span class="dl">"</span><span class="s2">arm-runner</span><span class="dl">"</span><span class="p">,</span>
  <span class="na">createNamespace</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
  <span class="na">values</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">runnerRegistrationToken</span><span class="p">:</span> <span class="dl">"</span><span class="s2">&lt;your-runner-token&gt;</span><span class="dl">"</span><span class="p">,</span>
    <span class="na">gitlabUrl</span><span class="p">:</span> <span class="dl">"</span><span class="s2">&lt;your-gitlab-url&gt;</span><span class="dl">"</span><span class="p">,</span>
    <span class="na">privileged</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
    <span class="na">rbac</span><span class="p">:</span> <span class="p">{</span>
      <span class="na">create</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
      <span class="na">rules</span><span class="p">:</span> <span class="p">[</span>
        <span class="p">{</span>
          <span class="na">apiGroups</span><span class="p">:</span> <span class="p">[</span><span class="dl">""</span><span class="p">],</span>
          <span class="na">resources</span><span class="p">:</span> <span class="p">[</span><span class="dl">"</span><span class="s2">pods</span><span class="dl">"</span><span class="p">],</span>
          <span class="na">verbs</span><span class="p">:</span> <span class="p">[</span><span class="dl">"</span><span class="s2">list</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">get</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">create</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">watch</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">delete</span><span class="dl">"</span><span class="p">],</span>
        <span class="p">},</span>
        <span class="p">{</span>
          <span class="na">apiGroups</span><span class="p">:</span> <span class="p">[</span><span class="dl">""</span><span class="p">],</span>
          <span class="na">resources</span><span class="p">:</span> <span class="p">[</span><span class="dl">"</span><span class="s2">pods/exec</span><span class="dl">"</span><span class="p">],</span>
          <span class="na">verbs</span><span class="p">:</span> <span class="p">[</span><span class="dl">"</span><span class="s2">create</span><span class="dl">"</span><span class="p">],</span>
        <span class="p">},</span>
        <span class="p">{</span>
          <span class="na">apiGroups</span><span class="p">:</span> <span class="p">[</span><span class="dl">""</span><span class="p">],</span>
          <span class="na">resources</span><span class="p">:</span> <span class="p">[</span><span class="dl">"</span><span class="s2">pods/log</span><span class="dl">"</span><span class="p">],</span>
          <span class="na">verbs</span><span class="p">:</span> <span class="p">[</span><span class="dl">"</span><span class="s2">get</span><span class="dl">"</span><span class="p">],</span>
        <span class="p">},</span>
        <span class="p">{</span>
          <span class="na">apiGroups</span><span class="p">:</span> <span class="p">[</span><span class="dl">""</span><span class="p">],</span>
          <span class="na">resources</span><span class="p">:</span> <span class="p">[</span><span class="dl">"</span><span class="s2">pods/attach</span><span class="dl">"</span><span class="p">],</span>
          <span class="na">verbs</span><span class="p">:</span> <span class="p">[</span><span class="dl">"</span><span class="s2">list</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">get</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">create</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">update</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">delete</span><span class="dl">"</span><span class="p">],</span>
        <span class="p">},</span>
        <span class="p">{</span>
          <span class="na">apiGroups</span><span class="p">:</span> <span class="p">[</span><span class="dl">""</span><span class="p">],</span>
          <span class="na">resources</span><span class="p">:</span> <span class="p">[</span><span class="dl">"</span><span class="s2">secrets</span><span class="dl">"</span><span class="p">],</span>
          <span class="na">verbs</span><span class="p">:</span> <span class="p">[</span><span class="dl">"</span><span class="s2">list</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">get</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">create</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">update</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">delete</span><span class="dl">"</span><span class="p">],</span>
        <span class="p">},</span>
        <span class="p">{</span>
          <span class="na">apiGroups</span><span class="p">:</span> <span class="p">[</span><span class="dl">""</span><span class="p">],</span>
          <span class="na">resources</span><span class="p">:</span> <span class="p">[</span><span class="dl">"</span><span class="s2">configmaps</span><span class="dl">"</span><span class="p">],</span>
          <span class="na">verbs</span><span class="p">:</span> <span class="p">[</span><span class="dl">"</span><span class="s2">list</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">get</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">create</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">update</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">delete</span><span class="dl">"</span><span class="p">],</span>
        <span class="p">}</span>
      <span class="p">]</span>
    <span class="p">},</span>
    <span class="na">runners</span><span class="p">:</span> <span class="p">{</span>
      <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">arm-runner</span><span class="dl">"</span><span class="p">,</span>
      <span class="na">tags</span><span class="p">:</span> <span class="dl">"</span><span class="s2">arm, mass</span><span class="dl">"</span><span class="p">,</span>
      <span class="na">runUntagged</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
      <span class="na">helpers</span><span class="p">:</span> <span class="p">{</span>
        <span class="na">image</span><span class="p">:</span> <span class="dl">"</span><span class="s2">gitlab/gitlab-runner-helper:arm64-v14.10.2</span><span class="dl">"</span>
      <span class="p">},</span>
      <span class="na">config</span><span class="p">:</span> <span class="s2">`
    [[runners]]
    name = "arm-runner"
    environment = ["FF_USE_LEGACY_KUBERNETES_EXECUTION_STRATEGY=true"]
    executor = "kubernetes"
    [runners.kubernetes]
      image = "ubuntu:22.04"
      privileged = true
    [[runners.kubernetes.volumes.empty_dir]]
      name = "docker-certs"
      mount_path = "/certs/client"
      medium = "Memory"
    [[runners.kubernetes.volumes.empty_dir]]
      name = "dind-storage"
      mount_path = "/var/lib/docker"
    [[runners.kubernetes.volumes.host_path]]
      name = "hostpath-modules"
      mount_path = "/lib/modules"
      read_only = true
      host_path = "/lib/modules"
    [[runners.kubernetes.volumes.host_path]]
      name = "hostpath-hosts"
      mount_path = "/etc/hosts"
      read_only = true
      host_path = "/etc/hosts"
    [[runners.kubernetes.volumes.host_path]]
      name = "hostpath-cgroup"
      mount_path = "/sys/fs/cgroup"
      host_path = "/sys/fs/cgroup"
    [runners.kubernetes.node_selector]
      "karpenter-arch" = "arm64" 
    `</span>
    <span class="p">},</span>
  <span class="p">}</span>
<span class="p">});</span>
</code></pre></div></div>

<p>Some notices:</p>

<ul>
  <li>Under ARM env, we need to specify the gitlab-runner-helper image, because the helper image is single-arch, default pattern is X86. This image will run as a sidecar for the build task.</li>
  <li><code class="language-plaintext highlighter-rouge">FF_USE_LEGACY_KUBERNETES_EXECUTION_STRATEGY</code> must be sett to true to execute pod.</li>
  <li><code class="language-plaintext highlighter-rouge">[runners.kubernetes.node_selector]</code> is prepared for K8S pod scheduling, which means the build tasks will be scheduled to the node node of the corresponding tag.</li>
</ul>

<h2 id="karpenter-provisioner">Karpenter Provisioner</h2>

<p><a href="https://karpenter.sh/">Karpenter</a> is a K8S node auto scaler built by AWS.</p>

<p>Here is the Karpenter Provisioner code.</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">karpenter.sh/v1alpha5</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Provisioner</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">arm-builder</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">requirements</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="na">key</span><span class="pi">:</span> <span class="s2">"</span><span class="s">karpenter.k8s.aws/instance-category"</span>
      <span class="na">operator</span><span class="pi">:</span> <span class="s">In</span>
      <span class="na">values</span><span class="pi">:</span> <span class="pi">[</span><span class="s2">"</span><span class="s">c"</span><span class="pi">,</span> <span class="s2">"</span><span class="s">m"</span><span class="pi">,</span> <span class="s2">"</span><span class="s">r"</span><span class="pi">]</span>
    <span class="pi">-</span> <span class="na">key</span><span class="pi">:</span> <span class="s">karpenter.sh/capacity-type</span>
      <span class="na">operator</span><span class="pi">:</span> <span class="s">In</span>
      <span class="na">values</span><span class="pi">:</span> <span class="pi">[</span><span class="s2">"</span><span class="s">spot"</span><span class="pi">]</span>
    <span class="pi">-</span> <span class="na">key</span><span class="pi">:</span> <span class="s2">"</span><span class="s">kubernetes.io/arch"</span>
      <span class="na">operator</span><span class="pi">:</span> <span class="s">In</span>
      <span class="na">values</span><span class="pi">:</span> <span class="pi">[</span><span class="s2">"</span><span class="s">arm64"</span><span class="pi">]</span>
  <span class="na">limits</span><span class="pi">:</span>
    <span class="na">resources</span><span class="pi">:</span>
      <span class="na">cpu</span><span class="pi">:</span> <span class="m">1000</span>
  <span class="na">labels</span><span class="pi">:</span>
    <span class="na">karpenter-arch</span><span class="pi">:</span> <span class="s">arm64</span>
  <span class="na">providerRef</span><span class="pi">:</span>
    <span class="na">name</span><span class="pi">:</span> <span class="s">default</span>
  <span class="na">ttlSecondsAfterEmpty</span><span class="pi">:</span> <span class="m">30</span>


<span class="nn">---</span>
<span class="na">apiVersion</span><span class="pi">:</span> <span class="s">karpenter.k8s.aws/v1alpha1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">AWSNodeTemplate</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">default</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">amiFamily</span><span class="pi">:</span> <span class="s">Bottlerocket</span>
  <span class="na">subnetSelector</span><span class="pi">:</span>
    <span class="s2">"</span><span class="s">aws:cloudformation:stack-name"</span><span class="err">:</span> <span class="s">gitlab</span>
    <span class="s">"aws-cdk:subnet-type": Private</span>
  <span class="na">securityGroupSelector</span><span class="pi">:</span>
    <span class="s2">"</span><span class="s">kubernetes.io/cluster/gitlab"</span><span class="err">:</span> <span class="s">owned</span>

</code></pre></div></div>

<p>Notices:</p>

<ul>
  <li>You can specify instance categories, CPU types, payment types, etc.</li>
  <li>We choose arm cpu and spot capacity type, this combination is the cheapest.</li>
  <li>It is recommended to use Bottlerocket as the os of node. Using Amazon Linux will throw an error that “Cannot resolve DNS address of the git repository”.</li>
</ul>

<h2 id="gitlab-ci-config">Gitlab CI config</h2>

<p>Now we need to schedule the build task to this runner.</p>

<p>Here is an example <code class="language-plaintext highlighter-rouge">.gitlab-ci.yml</code> code:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">stages</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="s">Build</span>

<span class="na">frontend-build</span><span class="pi">:</span>
  <span class="na">stage</span><span class="pi">:</span> <span class="s">Build</span>
  <span class="na">image</span><span class="pi">:</span> <span class="s">node:16.16.0-alpine</span>
  <span class="na">tags</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">arm</span>
  <span class="na">script</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">npm install</span>
    <span class="pi">-</span> <span class="s">npm run build</span>
  <span class="na">artifacts</span><span class="pi">:</span>
    <span class="na">paths</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">build/</span>
</code></pre></div></div>

<p>You only need to specify the tags for the build task.</p>

<h2 id="summary">Summary</h2>

<p>Through the above three configurations, the overall CI process is as follows:</p>

<p>Trigger Gitlab build -&gt; Look for runner with arm tag -&gt; Start build task (pod) -&gt; Look for <code class="language-plaintext highlighter-rouge">karpenter-arch: arm64</code> node -&gt; No arm node, pod pending -&gt; Karpenter purchase arm + spot node -&gt; The build task starts -&gt; The task ends and the node is released.</p>

<p>As shown in the figure below:</p>

<p><img src="/assets/posts/devops/gitlab-ci-karpenter.png" alt="Gitlab CI with karpenter" /></p>

<p>A whole new node purchase time is about 1 min 30s, Karpenter will always look for the cheapest instance.</p>]]></content><author><name>啤酒云</name></author><category term="aws," /><category term="gitlab," /><category term="devops," /><category term="container" /><summary type="html"><![CDATA[Graviton (ARM) is the most cost-effective in AWS (up to 40% savings), while Spot instances are suitable for task-type workloads and can save up to 90%. Gitlab Runner can easily schedule build tasks to Graviton + Spot instances.]]></summary></entry><entry><title type="html">使用 Gitlab in K8S 构建 Maven 类库到 AWS CodeArtifact</title><link href="https://youbug.cn/2022/12/build-maven-artifact-to-codeartifact.html" rel="alternate" type="text/html" title="使用 Gitlab in K8S 构建 Maven 类库到 AWS CodeArtifact" /><published>2022-12-12T12:59:33+00:00</published><updated>2022-12-12T12:59:33+00:00</updated><id>https://youbug.cn/2022/12/build-maven-artifact-to-codeartifact</id><content type="html" xml:base="https://youbug.cn/2022/12/build-maven-artifact-to-codeartifact.html"><![CDATA[<p>在很多项目里，需要共享类库，所以需要一个构建物仓库，在 AWS 就是 CodeArtifact。本文记录了如何使用 Gitlab 自动化构建 Java 类库，并上传到 CodeArtifact。</p>

<h2 id="创建-codeartifact">创建 CodeArtifact</h2>

<p>打开控制台进行创建: <a href="https://console.aws.amazon.com/codesuite/codeartifact/getting-started">https://console.aws.amazon.com/codesuite/codeartifact/getting-started</a>，选择 maven-central-store。</p>

<p>记得选择合适的 region，与您 Gitlab 部署地点尽量靠近。</p>

<p><img src="/assets/posts/devops/code-artifact.png" alt="CodeArtifact Create" /></p>

<p>创建完成后，可以查看连接说明。</p>

<h2 id="配置-maven-的-settings">配置 Maven 的 settings</h2>

<p>官方文档是将 settings.xml 配置到了宿主机，但在 k8s 中，可以考虑动态配置此文件。</p>

<p>我们将 settings.xml 的内容先丢到 Gitlab 的变量中去。我存在 <code class="language-plaintext highlighter-rouge">M2_SETTINGS</code> 变量里了。</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;settings&gt;</span>
  <span class="nt">&lt;profiles&gt;</span>
    <span class="nt">&lt;profile&gt;</span>
      <span class="nt">&lt;id&gt;</span>cloudbeer-mvn<span class="nt">&lt;/id&gt;</span>
      <span class="nt">&lt;activation&gt;</span>
        <span class="nt">&lt;activeByDefault&gt;</span>true<span class="nt">&lt;/activeByDefault&gt;</span>
      <span class="nt">&lt;/activation&gt;</span>
      <span class="nt">&lt;repositories&gt;</span>
        <span class="nt">&lt;repository&gt;</span>
          <span class="nt">&lt;id&gt;</span>cloudbeer-mvn<span class="nt">&lt;/id&gt;</span>
          <span class="nt">&lt;url&gt;</span>$${ARTIFACT_URL}<span class="nt">&lt;/url&gt;</span>
        <span class="nt">&lt;/repository&gt;</span>
      <span class="nt">&lt;/repositories&gt;</span>
    <span class="nt">&lt;/profile&gt;</span>
  <span class="nt">&lt;/profiles&gt;</span>
  <span class="nt">&lt;servers&gt;</span>
    <span class="nt">&lt;server&gt;</span>
      <span class="nt">&lt;id&gt;</span>cloudbeer-mvn<span class="nt">&lt;/id&gt;</span>
      <span class="nt">&lt;username&gt;</span>aws<span class="nt">&lt;/username&gt;</span>
      <span class="nt">&lt;password&gt;</span>$${CODEARTIFACT_AUTH_TOKEN}<span class="nt">&lt;/password&gt;</span>
    <span class="nt">&lt;/server&gt;</span>
  <span class="nt">&lt;/servers&gt;</span>
<span class="nt">&lt;/settings&gt;</span>
</code></pre></div></div>

<ul>
  <li>此变量会以环境变量 <code class="language-plaintext highlighter-rouge">M2_SETTINGS</code> 出现在 Pod 中。</li>
  <li>ARTIFACT_URL 会直接被 Gitlab 的替换，CODEARTIFACT_AUTH_TOKEN 会在 CI 过程中动态获取。</li>
  <li>这里不能用 <code class="language-plaintext highlighter-rouge">${CODEARTIFACT_AUTH_TOKEN}</code> 这样方式，会被 CI 过程替提前换掉，转义字符是 <strong>$$</strong>。</li>
</ul>

<h2 id="设置-gitlab-ci">设置 Gitlab CI</h2>

<p>添加如下的 <code class="language-plaintext highlighter-rouge">.gitlab-ci.yml</code> 文件：</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">stages</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="s">mvn-deploy</span>

<span class="na">build</span><span class="pi">:</span>
  <span class="na">image</span><span class="pi">:</span> <span class="s">maven:latest</span>
  <span class="na">stage</span><span class="pi">:</span> <span class="s">mvn-deploy</span>
  <span class="na">before_script</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">mkdir -p ~/.m2/repository</span>
    <span class="pi">-</span> <span class="s">apt update</span>
    <span class="pi">-</span> <span class="s">apt install unzip</span>
    <span class="pi">-</span> <span class="s">cd /tmp</span>
    <span class="pi">-</span> <span class="s">curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"</span>
    <span class="pi">-</span> <span class="s">unzip awscliv2.zip</span>
    <span class="pi">-</span> <span class="s">./aws/install</span>
    <span class="pi">-</span> <span class="s">export CODEARTIFACT_AUTH_TOKEN=`aws codeartifact get-authorization-token --domain cloudbeer --domain-owner $AWS_ACCOUNT_ID --region $AWS_REGION --query authorizationToken --output text`</span>
  <span class="na">script</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">cd $CI_PROJECT_DIR</span>
    <span class="pi">-</span> <span class="s">mvn deploy "-Daether.checksums.algorithms=MD5"</span>
</code></pre></div></div>

<ul>
  <li>使用了 maven 作为编译镜像，并安装了 aws cli 命令行工具。</li>
  <li>通过 shell 脚本将动态 CODEARTIFACT_AUTH_TOKEN 和仓库地址 ARTIFACT_URL 替换掉并写入 <code class="language-plaintext highlighter-rouge">.m2/settings.xml</code> 配置信息中。</li>
  <li><code class="language-plaintext highlighter-rouge">-Daether.checksums.algorithms=MD5</code> 这个解决上传过程的 checksum 警告信息。</li>
</ul>

<blockquote>
  <p>本文中，设置了如下的环境变量：</p>

  <ul>
    <li>ARTIFACT_URL: Maven / CodeArtifact 仓库地址</li>
    <li>M2_SETTINGS: Maven 的 .m2/settings.xml 配置</li>
    <li>AWS_ACCESS_KEY_ID</li>
    <li>AWS_SECRET_ACCESS_KEY</li>
    <li>AWS_REGION</li>
    <li>AWS_ACCOUNT_ID</li>
  </ul>
</blockquote>

<h2 id="build-by-tag">Build by Tag</h2>

<p>正式版本类库我们只想被 tag 触发。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git tag v1.0.0
git push origin v1.0.0
</code></pre></div></div>

<p>可以添加 <code class="language-plaintext highlighter-rouge">only: tags</code> 触发标记，整体如下：</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">stages</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="s">mvn-deploy</span>

<span class="na">build</span><span class="pi">:</span>
  <span class="na">image</span><span class="pi">:</span> <span class="s">maven:latest</span>
  <span class="na">stage</span><span class="pi">:</span> <span class="s">mvn-deploy</span>
  <span class="na">only</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">tags</span>
  <span class="na">before_script</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">mkdir -p ~/.m2/repository</span>
    <span class="pi">-</span> <span class="s">apt update</span>
    <span class="pi">-</span> <span class="s">apt install unzip</span>
    <span class="pi">-</span> <span class="s">cd /tmp</span>
    <span class="pi">-</span> <span class="s">curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"</span>
    <span class="pi">-</span> <span class="s">unzip awscliv2.zip</span>
    <span class="pi">-</span> <span class="s">./aws/install</span>
    <span class="pi">-</span> <span class="s">export CODEARTIFACT_AUTH_TOKEN=`aws codeartifact get-authorization-token --domain cloudbeer --domain-owner $AWS_ACCOUNT_ID --region $AWS_REGION --query authorizationToken --output text`</span>
  <span class="na">script</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">cd $CI_PROJECT_DIR</span>
    <span class="pi">-</span> <span class="s">mvn deploy "-Daether.checksums.algorithms=MD5"</span>
</code></pre></div></div>

<blockquote>
  <p>请注意，设置了 protected 的环境变量默认不能被传入 tags 触发的构建过程。</p>

  <p>这个可以修改，在项目的 Settings -&gt; Repository -&gt; Protected tags，可以将 tag 为 <code class="language-plaintext highlighter-rouge">v*</code> 或者 <code class="language-plaintext highlighter-rouge">*-release</code> 的保护起来。</p>

  <p>比如：您需要查询一下 <code class="language-plaintext highlighter-rouge">*-release</code>，然后选择最底下的 Create wildcard 才能创建匹配规则。</p>

  <p><img src="/assets/posts/devops/gitlab-protected-tags.png" alt="Protected tags" /></p>
</blockquote>

<p>同时 Java 项目的 pom.xml 可以写成这样：</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="nt">&lt;project</span> <span class="na">xmlns=</span><span class="s">"http://maven.apache.org/POM/4.0.0"</span>
    <span class="na">xmlns:xsi=</span><span class="s">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="na">xsi:schemaLocation=</span><span class="s">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;modelVersion&gt;</span>4.0.0<span class="nt">&lt;/modelVersion&gt;</span>

    <span class="nt">&lt;groupId&gt;</span>com.amazon.devax<span class="nt">&lt;/groupId&gt;</span>
    <span class="nt">&lt;artifactId&gt;</span>eshop-commons<span class="nt">&lt;/artifactId&gt;</span>
    <span class="nt">&lt;version&gt;</span>${version}<span class="nt">&lt;/version&gt;</span>

    <span class="nt">&lt;packaging&gt;</span>jar<span class="nt">&lt;/packaging&gt;</span>
    <span class="nt">&lt;properties&gt;</span>
        <span class="nt">&lt;version</span> <span class="na">default-value=</span><span class="s">"1.0.0-SNAPSHOT"</span><span class="nt">&gt;</span>${env.CI_COMMIT_TAG}<span class="nt">&lt;/version&gt;</span>
    <span class="nt">&lt;/properties&gt;</span>

    <span class="nt">&lt;dependencies&gt;</span>
    <span class="nt">&lt;/dependencies&gt;</span>
    <span class="nt">&lt;distributionManagement&gt;</span>
        <span class="nt">&lt;repository&gt;</span>
            <span class="nt">&lt;id&gt;</span>cloudbeer-mvn<span class="nt">&lt;/id&gt;</span>
            <span class="nt">&lt;url&gt;</span>${env.ARTIFACT_URL}<span class="nt">&lt;/url&gt;</span>
        <span class="nt">&lt;/repository&gt;</span>
    <span class="nt">&lt;/distributionManagement&gt;</span>
<span class="nt">&lt;/project&gt;</span>

</code></pre></div></div>

<ul>
  <li>version 这个属性取自环境变量 CI_COMMIT_TAG 这个值，这个环境变量就是 git commit 的 tag 名称。</li>
  <li>最后 deploy 的时候，会发现 release artifact 的版本号和 git 的 tag 保持一致。</li>
</ul>

<hr />

<p>参考文档：</p>

<ul>
  <li><a href="https://docs.gitlab.com/ee/user/packages/maven_repository/">Maven packages in the Package Repository</a></li>
  <li><a href="https://docs.aws.amazon.com/zh_cn/cli/latest/userguide/getting-started-install.html">安装或更新最新版本的 AWS CLI</a></li>
  <li><a href="https://docs.aws.amazon.com/codeartifact/latest/ug/maven-mvn.html">Use CodeArtifact with mvn</a></li>
</ul>]]></content><author><name>啤酒云</name></author><category term="aws," /><category term="gitlab," /><category term="devops," /><category term="container" /><summary type="html"><![CDATA[在很多项目里，需要共享类库，所以需要一个构建物仓库，在 AWS 就是 CodeArtifact。本文记录了如何使用 Gitlab 自动化构建 Java 类库，并上传到 CodeArtifact。]]></summary></entry><entry><title type="html">在 AWS EKS 中部署 Gitlab</title><link href="https://youbug.cn/2022/12/gitlab-in-eks.html" rel="alternate" type="text/html" title="在 AWS EKS 中部署 Gitlab" /><published>2022-12-10T09:50:33+00:00</published><updated>2022-12-10T09:50:33+00:00</updated><id>https://youbug.cn/2022/12/gitlab-in-eks</id><content type="html" xml:base="https://youbug.cn/2022/12/gitlab-in-eks.html"><![CDATA[<p>本文记录了 Gitlab 在 Kubernetes 中的安装过程，目标是构建出生产可用的 Gitlab 系统。本文以 AWS EKS 为例。</p>

<h2 id="在-aws-部署-gitlab-的前提条件">在 AWS 部署 Gitlab 的前提条件</h2>

<p>首先需要创建出合适的集群，Gitlab 对 EKS 集群的需求基本需求如下：</p>

<ul>
  <li>Ingress: 需要安装 aws-load-balancer</li>
  <li>PV 卷: 需要安装 ebs-csi-driver</li>
  <li>HPA: 需要安装 metrics-server</li>
</ul>

<p>生产环境下：</p>

<ul>
  <li>PostgresSQL: 安装 RDS for Postgres。</li>
  <li>Redis: 安装 ElasticCache for Reids。</li>
</ul>

<p>高级特性(非必须，这部分内容稍后探讨)：</p>

<ul>
  <li>CI 过程的优化: 创建 Karpenter Provisinor</li>
  <li>CI 缓存: 创建 S3 存储桶</li>
  <li>数据存储的高可用</li>
</ul>

<p>因为 Gitlab 不会创建数据库本身，<strong>需要首先在 Postgres 里创建一个数据库</strong> <code class="language-plaintext highlighter-rouge">gitlab</code>，这个库名可以自定义，稍后指定到安装配置里。</p>

<h2 id="部署-gitlab">部署 Gitlab</h2>

<p>首先在 EKS 中 创建命名空间 gitlab：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl create ns gitlab
</code></pre></div></div>

<p>创建数据库和 SMTP Server 的密码 Secret:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl apply <span class="nt">-f</span> - <span class="o">&lt;&lt;</span> <span class="no">EOF</span><span class="sh">
apiVersion: v1
kind: Secret
metadata:
  name: gitlab-password
  namespace: gitlab
type: Opaque  
stringData:
  psql-password: &lt;your-psql-secret&gt;
  smtp-password: &lt;your-smtp-password&gt;
</span><span class="no">EOF
</span></code></pre></div></div>

<ul>
  <li>这里的 name 和 key 可以自定义，稍后需要定义到 HelmChart 的配置中。</li>
  <li>用户名是直接明文写在 Gitlab 的配置中的。</li>
  <li>Secret 需要配置到 Gitlab 的安装 namespace。</li>
</ul>

<p>下面是完整的 HelmChart 的配置，这里的格式是 CDK，如果您使用 Helm 直接安装，试着转换成 Values.yaml:</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="p">{</span> <span class="nx">ClusterInfo</span><span class="p">,</span> <span class="nx">ClusterAddOn</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">@aws-quickstart/eks-blueprints</span><span class="dl">'</span><span class="p">;</span>


<span class="kd">const</span> <span class="nx">smtpEmail</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">cloudeer@gmail.com</span><span class="dl">"</span><span class="p">;</span>
<span class="kd">const</span> <span class="nx">psqlAddress</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">&lt;postgres-address&gt;</span><span class="dl">"</span><span class="p">;</span>
<span class="kd">const</span> <span class="nx">redisAddress</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">&lt;redis-address&gt;</span><span class="dl">"</span><span class="p">;</span>

<span class="k">export</span> <span class="kd">class</span> <span class="nx">GitlabAddon</span> <span class="k">implements</span> <span class="nx">ClusterAddOn</span> <span class="p">{</span>
  <span class="kd">constructor</span><span class="p">()</span> <span class="p">{</span>
  <span class="p">}</span>
  <span class="nx">deploy</span><span class="p">(</span><span class="nx">clusterInfo</span><span class="p">:</span> <span class="nx">ClusterInfo</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">vpc</span> <span class="o">=</span> <span class="nx">clusterInfo</span><span class="p">.</span><span class="nx">cluster</span><span class="p">.</span><span class="nx">vpc</span><span class="p">;</span>
    <span class="kd">const</span> <span class="nx">scope</span> <span class="o">=</span> <span class="nx">clusterInfo</span><span class="p">.</span><span class="nx">getResourceContext</span><span class="p">().</span><span class="nx">scope</span><span class="p">;</span>

    <span class="nx">clusterInfo</span><span class="p">.</span><span class="nx">cluster</span><span class="p">.</span><span class="nx">addHelmChart</span><span class="p">(</span><span class="dl">"</span><span class="s2">gitlab</span><span class="dl">"</span><span class="p">,</span> <span class="p">{</span>
      <span class="na">chart</span><span class="p">:</span> <span class="dl">"</span><span class="s2">gitlab</span><span class="dl">"</span><span class="p">,</span>
      <span class="na">repository</span><span class="p">:</span> <span class="dl">"</span><span class="s2">http://charts.gitlab.io/</span><span class="dl">"</span><span class="p">,</span>
      <span class="na">version</span><span class="p">:</span> <span class="dl">"</span><span class="s2">6.6.2</span><span class="dl">"</span><span class="p">,</span>
      <span class="na">namespace</span><span class="p">:</span> <span class="dl">"</span><span class="s2">gitlab</span><span class="dl">"</span><span class="p">,</span>
      <span class="na">release</span><span class="p">:</span> <span class="dl">"</span><span class="s2">abigfun</span><span class="dl">"</span><span class="p">,</span>
      <span class="na">createNamespace</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
      <span class="na">values</span><span class="p">:</span> <span class="p">{</span>
        <span class="na">global</span><span class="p">:</span> <span class="p">{</span>
          <span class="na">hosts</span><span class="p">:</span> <span class="p">{</span>
            <span class="na">domain</span><span class="p">:</span> <span class="dl">"</span><span class="s2">abig.fun</span><span class="dl">"</span><span class="p">,</span>
            <span class="na">https</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
          <span class="p">},</span>
          <span class="na">shell</span><span class="p">:</span> <span class="p">{</span>
            <span class="na">tcp</span><span class="p">:</span> <span class="p">{</span>
              <span class="na">proxyProtocol</span><span class="p">:</span> <span class="kc">true</span>
            <span class="p">}</span>
          <span class="p">},</span>
          <span class="na">email</span><span class="p">:</span> <span class="p">{</span>
            <span class="na">display_name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">GitLab</span><span class="dl">'</span><span class="p">,</span>
            <span class="na">from</span><span class="p">:</span> <span class="nx">smtpEmail</span><span class="p">,</span>
            <span class="na">reply_to</span><span class="p">:</span> <span class="nx">smtpEmail</span>
          <span class="p">},</span>
          <span class="na">smtp</span><span class="p">:</span> <span class="p">{</span>
            <span class="na">enabled</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
            <span class="na">address</span><span class="p">:</span> <span class="dl">'</span><span class="s1">smtp.gmail.com</span><span class="dl">'</span><span class="p">,</span>
            <span class="na">tls</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
            <span class="na">port</span><span class="p">:</span> <span class="mi">587</span><span class="p">,</span>
            <span class="na">authentication</span><span class="p">:</span> <span class="dl">'</span><span class="s1">login</span><span class="dl">'</span><span class="p">,</span>
            <span class="na">user_name</span><span class="p">:</span> <span class="nx">smtpEmail</span><span class="p">,</span>
            <span class="na">starttls_auto</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
            <span class="na">openssl_verify_mode</span><span class="p">:</span> <span class="dl">'</span><span class="s1">peer</span><span class="dl">'</span><span class="p">,</span>
            <span class="na">password</span><span class="p">:</span> <span class="p">{</span>
              <span class="na">secret</span><span class="p">:</span> <span class="dl">'</span><span class="s1">gitlab-password</span><span class="dl">'</span><span class="p">,</span>
              <span class="na">key</span><span class="p">:</span> <span class="dl">'</span><span class="s1">smtp-password</span><span class="dl">'</span>
            <span class="p">}</span>

          <span class="p">},</span>
          <span class="na">ingress</span><span class="p">:</span> <span class="p">{</span>
            <span class="na">tls</span><span class="p">:</span> <span class="p">{</span>
              <span class="na">enabled</span><span class="p">:</span> <span class="kc">false</span>
            <span class="p">},</span>
            <span class="na">configureCertmanager</span><span class="p">:</span> <span class="kc">false</span>
          <span class="p">},</span>
          <span class="na">psql</span><span class="p">:</span> <span class="p">{</span>
            <span class="na">host</span><span class="p">:</span> <span class="nx">psqlAddress</span><span class="p">,</span>
            <span class="na">port</span><span class="p">:</span> <span class="mi">5432</span><span class="p">,</span>
            <span class="na">username</span><span class="p">:</span> <span class="dl">"</span><span class="s2">postgres</span><span class="dl">"</span><span class="p">,</span>
            <span class="na">database</span><span class="p">:</span> <span class="dl">"</span><span class="s2">gitlab</span><span class="dl">"</span><span class="p">,</span>
            <span class="na">password</span><span class="p">:</span> <span class="p">{</span>
              <span class="na">secret</span><span class="p">:</span> <span class="dl">"</span><span class="s2">gitlab-password</span><span class="dl">"</span><span class="p">,</span>
              <span class="na">key</span><span class="p">:</span> <span class="dl">"</span><span class="s2">psql-password</span><span class="dl">"</span>
            <span class="p">},</span>
          <span class="p">},</span>
          <span class="na">redis</span><span class="p">:</span> <span class="p">{</span>
            <span class="na">host</span><span class="p">:</span> <span class="nx">redisAddress</span><span class="p">,</span>
            <span class="na">port</span><span class="p">:</span> <span class="mi">6379</span><span class="p">,</span>
            <span class="na">password</span><span class="p">:</span> <span class="p">{</span>
              <span class="na">enabled</span><span class="p">:</span> <span class="kc">false</span>
            <span class="p">}</span>
          <span class="p">}</span>
        <span class="p">},</span>
        <span class="na">redis</span><span class="p">:</span> <span class="p">{</span>
          <span class="na">install</span><span class="p">:</span> <span class="kc">false</span>
        <span class="p">},</span>
        <span class="na">postgresql</span><span class="p">:</span> <span class="p">{</span>
          <span class="na">install</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="dl">"</span><span class="s2">nginx-ingress</span><span class="dl">"</span><span class="p">:</span> <span class="p">{</span>
          <span class="na">controller</span><span class="p">:</span> <span class="p">{</span>
            <span class="na">service</span><span class="p">:</span> <span class="p">{</span>
              <span class="na">annotations</span><span class="p">:</span> <span class="p">{</span>
                <span class="dl">"</span><span class="s2">service.beta.kubernetes.io/aws-load-balancer-backend-protocol</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">tcp</span><span class="dl">"</span><span class="p">,</span>
                <span class="dl">"</span><span class="s2">service.beta.kubernetes.io/aws-load-balancer-proxy-protocol</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">*</span><span class="dl">"</span>
              <span class="p">}</span>
            <span class="p">},</span>
            <span class="na">config</span><span class="p">:</span> <span class="p">{</span>
              <span class="dl">"</span><span class="s2">use-proxy-protocol</span><span class="dl">"</span><span class="p">:</span> <span class="kc">true</span>
            <span class="p">}</span>
          <span class="p">}</span>
        <span class="p">},</span>
        <span class="dl">"</span><span class="s2">gitlab-runner</span><span class="dl">"</span><span class="p">:</span> <span class="p">{</span>
          <span class="na">runners</span><span class="p">:</span> <span class="p">{</span>
            <span class="na">privileged</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
            <span class="na">config</span><span class="p">:</span> <span class="s2">`
[[runners]]
  [runners.kubernetes]
    image = "ubuntu:20.04"
    privileged = true
  [[runners.kubernetes.volumes.empty_dir]]
    name = "docker-certs"
    mount_path = "/certs/client"
    medium = "Memory"
  [[runners.kubernetes.volumes.empty_dir]]
    name = "dind-storage"
    mount_path = "/var/lib/docker"
  [[runners.kubernetes.volumes.host_path]]
    name = "hostpath-modules"
    mount_path = "/lib/modules"
    read_only = true
    host_path = "/lib/modules"
  [[runners.kubernetes.volumes.host_path]]
    name = "hostpath-cgroup"
    mount_path = "/sys/fs/cgroup"
    host_path = "/sys/fs/cgroup"
            `</span>
          <span class="p">}</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">});</span>
  <span class="p">}</span>
<span class="p">}</span>

</code></pre></div></div>

<p>代码解读：</p>

<ul>
  <li>需要配置一个域名，最好这个域名是真实的。本例中使用的是: abig.fun</li>
  <li>Gitlab 安装了一个 NginxIngress Controller，所以 AWS 的 LB 只需要使用 TCP 即可。</li>
  <li>在 K8S 里构建 docker 镜像，需要给 runner 提权，并配置一些 volumes 绑定，如上面的 gitlab-runner.runners.config 配置节点</li>
</ul>

<p>Gitlab 安装完成后，查看安装结果：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>❯ kubectl get po <span class="nt">-n</span> gitlab
NAME                                                READY   STATUS      RESTARTS       AGE
abigfun-certmanager-7c98d5576b-64q2l                1/1     Running     0              139m
abigfun-certmanager-cainjector-c74d89b67-w8gwj      1/1     Running     0              139m
abigfun-certmanager-webhook-6c4fbb8c86-rkfl6        1/1     Running     0              139m
abigfun-gitaly-0                                    1/1     Running     0              139m
abigfun-gitlab-exporter-fb9dc9776-f5llm             1/1     Running     0              139m
abigfun-gitlab-runner-6f75dd5f8f-snlx5              1/1     Running     8 <span class="o">(</span>109m ago<span class="o">)</span>   139m
abigfun-gitlab-shell-77b9f4fcf9-2lxw8               1/1     Running     0              139m
abigfun-gitlab-shell-77b9f4fcf9-h99gf               1/1     Running     0              139m
abigfun-kas-6b4c6b9b7c-snjt5                        1/1     Running     0              140m
abigfun-kas-6b4c6b9b7c-vrqmv                        1/1     Running     0              139m
abigfun-migrations-2-2pxlh                          0/1     Completed   0              44m
abigfun-minio-596cb868fd-g87wj                      1/1     Running     0              140m
abigfun-minio-create-buckets-2-r4l75                0/1     Completed   0              44m
abigfun-nginx-ingress-controller-59dc9b7959-7xlv2   1/1     Running     0              139m
abigfun-nginx-ingress-controller-59dc9b7959-q96mn   1/1     Running     0              139m
abigfun-prometheus-server-76944cc9cf-srptg          2/2     Running     0              139m
abigfun-registry-864b87ccd8-hgcv6                   1/1     Running     0              139m
abigfun-registry-864b87ccd8-qvvgl                   1/1     Running     0              139m
abigfun-sidekiq-all-in-1-v2-7c98fb88fd-vkk9w        1/1     Running     0              44m
abigfun-toolbox-89cd5c577-twctl                     1/1     Running     0              43m
abigfun-webservice-default-849d958f64-nqfhr         2/2     Running     0              44m
abigfun-webservice-default-849d958f64-rr9q7         2/2     Running     0              43m
</code></pre></div></div>

<h2 id="第一次运行-gitlab">第一次运行 Gitlab</h2>

<p>运行前，需要进行域名解析：</p>

<p>显示 ingress：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl get ing <span class="nt">-n</span> gitlab
</code></pre></div></div>

<p>会看到所有的 ingress 都绑定到了一个经典 LB。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>NAME                         CLASS           HOSTS               ADDRESS                                                                        PORTS   AGE
abigfun-kas                  abigfun-nginx   kas.abig.fun        xxxxxxxxxx.elb.amazonaws.com   80      58m
abigfun-minio                abigfun-nginx   minio.abig.fun      xxxxxxxxxx.elb.amazonaws.com   80      58m
abigfun-registry             abigfun-nginx   registry.abig.fun   xxxxxxxxxx.elb.amazonaws.com   80      58m
abigfun-webservice-default   abigfun-nginx   gitlab.abig.fun     xxxxxxxxxx.elb.amazonaws.com   80      58m
</code></pre></div></div>

<p>现在去添加解析。分别将上述 HOSTS 中的域名 CNAME 到 <code class="language-plaintext highlighter-rouge">xxxxxxxxxx.elb.amazonaws.com</code>。</p>

<p>等域名生效。访问 <a href="http://gitlab.abig.fun">http://gitlab.abig.fun</a></p>

<p>首先注册一个用户。</p>

<p>管理员账号：root</p>

<p>初始密码：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl get secret <span class="nt">--namespace</span> <span class="s2">"gitlab"</span> abigfun-gitlab-initial-root-password <span class="nt">-o</span> <span class="nv">jsonpath</span><span class="o">=</span><span class="s2">"{.data.password}"</span> | <span class="nb">base64</span> <span class="nt">-d</span>
</code></pre></div></div>

<p>使用管理账号进入之后，审批一下 刚刚注册的账号。</p>

<h2 id="功能测试">功能测试</h2>

<p>使用刚刚自己注册的账号登录，创建一个项目，并添加一个文件: <code class="language-plaintext highlighter-rouge">.gitlab-ci.yml</code>。 这部分可以测试 git 源代码管理功能。</p>

<p>.gitlab-ci.yml 的内容如下：</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">variables</span><span class="pi">:</span>
  <span class="na">DOCKER_DRIVER</span><span class="pi">:</span> <span class="s">overlay2</span>
  <span class="na">DOCKER_HOST</span><span class="pi">:</span> <span class="s">tcp://docker:2376</span>
  <span class="na">DOCKER_TLS_CERTDIR</span><span class="pi">:</span> <span class="s2">"</span><span class="s">/certs"</span>
  <span class="na">DOCKER_TLS_VERIFY</span><span class="pi">:</span> <span class="m">1</span>
  <span class="na">DOCKER_CERT_PATH</span><span class="pi">:</span> <span class="s2">"</span><span class="s">/certs/client"</span>

<span class="na">stages</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="s">package</span>

<span class="na">docker-build</span><span class="pi">:</span>
  <span class="na">image</span><span class="pi">:</span> <span class="s">docker:20</span>
  <span class="na">stage</span><span class="pi">:</span> <span class="s">package</span>
  <span class="na">services</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">docker:dind</span>
  <span class="na">before_script</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">sleep </span><span class="m">5</span>
    <span class="pi">-</span> <span class="s">docker info</span>
  <span class="na">script</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">echo "Hehe"</span>

</code></pre></div></div>

<ul>
  <li>上面的示例可以测试 docker dind 是否正常</li>
  <li>sleep 5 是为了…我也说不清，新版本的 docker 加一下这个就正常了，我觉得是个坑，搞了很久才发现是这个原因。</li>
</ul>

<p>水一段文字记录一下成功结果：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Running with gitlab-runner 15.6.0 <span class="o">(</span>44a1c2be<span class="o">)</span>
  on abigfun-gitlab-runner-8567dfbd8-bcg84 xJfSsxKi
Preparing the <span class="s2">"kubernetes"</span> executor
00:00
Using Kubernetes namespace: gitlab
Using Kubernetes executor with image docker:20 ...
Using attach strategy to execute scripts...
Preparing environment
00:03
Waiting <span class="k">for </span>pod gitlab/runner-xjfssxki-project-2-concurrent-0wrtsq to be running, status is Pending
Running on runner-xjfssxki-project-2-concurrent-0wrtsq via abigfun-gitlab-runner-8567dfbd8-bcg84...
Getting <span class="nb">source </span>from Git repository
00:01
Fetching changes with git depth <span class="nb">set </span>to 20...
Initialized empty Git repository <span class="k">in</span> /builds/[MASKED]/gateway/.git/
Created fresh repository.
Checking out 7fb43706 as main...
Skipping Git submodules setup
Executing <span class="s2">"step_script"</span> stage of the job script
00:06
<span class="nv">$ </span><span class="nb">sleep </span>5
<span class="nv">$ </span>docker info
Client:
 Context:    default
 Debug Mode: <span class="nb">false
 </span>Plugins:
  buildx: Docker Buildx <span class="o">(</span>Docker Inc., v0.9.1<span class="o">)</span>
  compose: Docker Compose <span class="o">(</span>Docker Inc., v2.14.0<span class="o">)</span>
Server:
 Containers: 0
  Running: 0
  Paused: 0
  Stopped: 0
 Images: 0
 Server Version: 20.10.21
 Storage Driver: overlay2
  Backing Filesystem: extfs
  Supports d_type: <span class="nb">true
  </span>Native Overlay Diff: <span class="nb">true
  </span>userxattr: <span class="nb">false
 </span>Logging Driver: json-file
 Cgroup Driver: cgroupfs
 Cgroup Version: 1
 Plugins:
  Volume: <span class="nb">local
  </span>Network: bridge host ipvlan macvlan null overlay
  Log: awslogs fluentd gcplogs gelf journald json-file <span class="nb">local </span>logentries splunk syslog
 Swarm: inactive
 Runtimes: io.containerd.runtime.v1.linux runc io.containerd.runc.v2
 Default Runtime: runc
 Init Binary: docker-init
 containerd version: 1c90a442489720eec95342e1789ee8a5e1b9536f
 runc version: v1.1.4-0-g5fd4c4d1
 init version: de40ad0
 Security Options:
  seccomp
   Profile: default
 Kernel Version: 5.10.135
 Operating System: Alpine Linux v3.17 <span class="o">(</span>containerized<span class="o">)</span>
 OSType: linux
 Architecture: x86_64
 CPUs: 2
 Total Memory: 7.655GiB
 Name: runner-xjfssxki-project-2-concurrent-0wrtsq
 ID: MS4S:WD6L:NYMX:Q2EK:AASW:ICI5:2PSL:DARY:5EZ5:FYNP:IPCK:3WVF
 Docker Root Dir: /var/lib/docker
 Debug Mode: <span class="nb">false
 </span>Registry: https://index.docker.io/v1/
 Labels:
 Experimental: <span class="nb">false
 </span>Insecure Registries:
  127.0.0.0/8
 Live Restore Enabled: <span class="nb">false
 </span>Product License: Community Engine
<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"Hehe"</span>
Hehe
Job succeeded
</code></pre></div></div>

<h2 id="其他">其他</h2>

<h3 id="创建内网-postgres-数据库">创建内网 Postgres 数据库</h3>

<p>数据库没有公网，没有跳板机，我使用了如下方法：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl run psql-client <span class="nt">-ndefault</span> <span class="nt">--env</span><span class="o">=</span><span class="s2">"POSTGRES_PASSWORD=pAssw0rd"</span> <span class="nt">--image</span><span class="o">=</span>postgres 
</code></pre></div></div>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl <span class="nb">exec</span> <span class="nt">-ndefault</span> <span class="nt">-it</span> psql-client <span class="nt">--</span> sh
</code></pre></div></div>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>psql <span class="nt">-h</span> &lt;postgres-host&gt; <span class="nt">-U</span> postgres <span class="nt">-W</span> 
</code></pre></div></div>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">DATABASE</span> <span class="n">gitlab</span><span class="p">;</span>
</code></pre></div></div>

<p>感觉好傻！</p>]]></content><author><name>啤酒云</name></author><category term="devops," /><category term="iac," /><category term="aws" /><category term="gitlab," /><category term="cdk," /><category term="eks" /><summary type="html"><![CDATA[本文记录了 Gitlab 在 Kubernetes 中的安装过程，目标是构建出生产可用的 Gitlab 系统。本文以 AWS EKS 为例。]]></summary></entry><entry><title type="html">使用 terraform 增加 EKS 组件</title><link href="https://youbug.cn/2022/12/modify-eks-by-terraform.html" rel="alternate" type="text/html" title="使用 terraform 增加 EKS 组件" /><published>2022-12-07T12:54:44+00:00</published><updated>2022-12-07T12:54:44+00:00</updated><id>https://youbug.cn/2022/12/modify-eks-by-terraform</id><content type="html" xml:base="https://youbug.cn/2022/12/modify-eks-by-terraform.html"><![CDATA[<p>在已经开通了 EKS 的情况下，使用 terraform 给 EKS 集群安装组件。</p>

<h2 id="常用-sdk">常用 SDK</h2>

<p>操作 EKS 的常用 SDK 如下：</p>

<div class="language-terraform highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">terraform</span> <span class="p">{</span>
  <span class="nx">required_providers</span> <span class="p">{</span>
    <span class="nx">aws</span> <span class="p">=</span> <span class="p">{</span>
      <span class="nx">source</span>  <span class="p">=</span> <span class="s2">"hashicorp/aws"</span>
      <span class="nx">version</span> <span class="p">=</span> <span class="s2">"~&gt; 4.40.0"</span>
    <span class="p">}</span>
    <span class="nx">kubernetes</span> <span class="p">=</span> <span class="p">{</span>
      <span class="nx">source</span>  <span class="p">=</span> <span class="s2">"hashicorp/kubernetes"</span>
      <span class="nx">version</span> <span class="p">=</span> <span class="s2">"&gt;= 2.15.0"</span>
    <span class="p">}</span>
    <span class="nx">helm</span> <span class="p">=</span> <span class="p">{</span>
      <span class="nx">source</span>  <span class="p">=</span> <span class="s2">"hashicorp/helm"</span>
      <span class="nx">version</span> <span class="p">=</span> <span class="s2">"~&gt; 2.7.1"</span>
    <span class="p">}</span>
    <span class="nx">kubectl</span> <span class="p">=</span> <span class="p">{</span>
      <span class="nx">source</span>  <span class="p">=</span> <span class="s2">"gavinbunney/kubectl"</span>
      <span class="nx">version</span> <span class="p">=</span> <span class="s2">"&gt;= 1.14.0"</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>hashicorp/aws: 操作 aws 资源</li>
  <li>hashicorp/kubernetes: 操作 k8s 资源</li>
  <li>hashicorp/helm: 操作 helm 图样</li>
  <li>gavinbunney/kubectl: 被广泛采用的个人工具，可以支持单资源 kubectl 操作</li>
</ul>

<h2 id="先决条件">先决条件</h2>

<p>对于已经创建资源，在 terraform 中，通常使用 data 去查询，如下代码，只需要指定 集群的 名字就可以查询到集群的信息：</p>

<div class="language-terraform highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">data</span> <span class="s2">"aws_eks_cluster"</span> <span class="s2">"main"</span> <span class="p">{</span>
  <span class="nx">name</span> <span class="p">=</span> <span class="kd">var</span><span class="p">.</span><span class="nx">cluster_name</span>
<span class="p">}</span>
</code></pre></div></div>

<p>对于 helm 和 kubectl 工具，我们需要为其配置相应的权限：</p>

<div class="language-terraform highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">provider</span> <span class="s2">"helm"</span> <span class="p">{</span>
  <span class="nx">kubernetes</span> <span class="p">{</span>
    <span class="nx">host</span>                   <span class="p">=</span> <span class="k">data</span><span class="p">.</span><span class="nx">aws_eks_cluster</span><span class="p">.</span><span class="nx">main</span><span class="p">.</span><span class="nx">endpoint</span>
    <span class="nx">cluster_ca_certificate</span> <span class="p">=</span> <span class="nx">base64decode</span><span class="p">(</span><span class="k">data</span><span class="p">.</span><span class="nx">aws_eks_cluster</span><span class="p">.</span><span class="nx">main</span><span class="p">.</span><span class="nx">certificate_authority</span><span class="p">.</span><span class="mi">0</span><span class="p">.</span><span class="k">data</span><span class="p">)</span>
    <span class="nx">exec</span> <span class="p">{</span>
      <span class="nx">api_version</span> <span class="p">=</span> <span class="s2">"client.authentication.k8s.io/v1beta1"</span>
      <span class="nx">args</span>        <span class="p">=</span> <span class="p">[</span><span class="s2">"eks"</span><span class="p">,</span> <span class="s2">"get-token"</span><span class="p">,</span> <span class="s2">"--cluster-name"</span><span class="p">,</span> <span class="kd">var</span><span class="p">.</span><span class="nx">cluster_name</span><span class="p">,</span> <span class="s2">"--region"</span><span class="p">,</span> <span class="kd">var</span><span class="p">.</span><span class="nx">region</span><span class="p">]</span>
      <span class="nx">command</span>     <span class="p">=</span> <span class="s2">"aws"</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">provider</span> <span class="s2">"kubectl"</span> <span class="p">{</span>
  <span class="nx">host</span>                   <span class="p">=</span> <span class="k">data</span><span class="p">.</span><span class="nx">aws_eks_cluster</span><span class="p">.</span><span class="nx">main</span><span class="p">.</span><span class="nx">endpoint</span>
  <span class="nx">cluster_ca_certificate</span> <span class="p">=</span> <span class="nx">base64decode</span><span class="p">(</span><span class="k">data</span><span class="p">.</span><span class="nx">aws_eks_cluster</span><span class="p">.</span><span class="nx">main</span><span class="p">.</span><span class="nx">certificate_authority</span><span class="p">.</span><span class="mi">0</span><span class="p">.</span><span class="k">data</span><span class="p">)</span>
  <span class="nx">exec</span> <span class="p">{</span>
    <span class="nx">api_version</span> <span class="p">=</span> <span class="s2">"client.authentication.k8s.io/v1beta1"</span>
    <span class="nx">args</span>        <span class="p">=</span> <span class="p">[</span><span class="s2">"eks"</span><span class="p">,</span> <span class="s2">"get-token"</span><span class="p">,</span> <span class="s2">"--cluster-name"</span><span class="p">,</span> <span class="kd">var</span><span class="p">.</span><span class="nx">cluster_name</span><span class="p">,</span> <span class="s2">"--region"</span><span class="p">,</span> <span class="kd">var</span><span class="p">.</span><span class="nx">region</span><span class="p">]</span>
    <span class="nx">command</span>     <span class="p">=</span> <span class="s2">"aws"</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="使用-helm-安装组件">使用 helm 安装组件</h2>

<p>使用 helm 安装非常简单，参照 helm 图样的说明即可，传入相应的参数.</p>

<p>下面的代码是在集群内安装 Gitlab 的示例：</p>

<div class="language-terraform highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">variable</span> <span class="s2">"namespace"</span> <span class="p">{</span>
  <span class="nx">type</span>    <span class="p">=</span> <span class="nx">string</span>
  <span class="nx">default</span> <span class="p">=</span> <span class="s2">"gitlab"</span>
<span class="p">}</span>

<span class="k">variable</span> <span class="s2">"name"</span> <span class="p">{</span>
  <span class="nx">type</span>    <span class="p">=</span> <span class="nx">string</span>
  <span class="nx">default</span> <span class="p">=</span> <span class="s2">"gitlab"</span>
<span class="p">}</span>

<span class="k">variable</span> <span class="s2">"domain"</span> <span class="p">{</span>
  <span class="nx">type</span> <span class="p">=</span> <span class="nx">string</span>
<span class="p">}</span>

<span class="k">resource</span> <span class="s2">"helm_release"</span> <span class="s2">"gitlab"</span> <span class="p">{</span>
  <span class="nx">namespace</span>        <span class="p">=</span> <span class="kd">var</span><span class="p">.</span><span class="nx">namespace</span>
  <span class="nx">create_namespace</span> <span class="p">=</span> <span class="kc">true</span>
  <span class="nx">name</span>             <span class="p">=</span> <span class="kd">var</span><span class="p">.</span><span class="nx">name</span>
  <span class="nx">repository</span>       <span class="p">=</span> <span class="s2">"https://charts.gitlab.io/"</span>
  <span class="nx">chart</span>            <span class="p">=</span> <span class="s2">"gitlab"</span>
  <span class="nx">version</span>          <span class="p">=</span> <span class="s2">"6.5.5"</span>

  <span class="nx">set</span> <span class="p">{</span>
    <span class="nx">name</span>  <span class="p">=</span> <span class="s2">"global.ingress.enabled"</span>
    <span class="nx">value</span> <span class="p">=</span> <span class="kc">false</span>
  <span class="p">}</span>
  <span class="nx">set</span> <span class="p">{</span>
    <span class="nx">name</span>  <span class="p">=</span> <span class="s2">"global.ingress.configureCertmanager"</span>
    <span class="nx">value</span> <span class="p">=</span> <span class="kc">false</span>
  <span class="p">}</span>
  <span class="nx">set</span> <span class="p">{</span>
    <span class="nx">name</span>  <span class="p">=</span> <span class="s2">"gitlab.certmanager.install"</span>
    <span class="nx">value</span> <span class="p">=</span> <span class="kc">false</span>
  <span class="p">}</span>
  <span class="nx">set</span> <span class="p">{</span>
    <span class="nx">name</span>  <span class="p">=</span> <span class="s2">"gitlab.prometheus.install"</span>
    <span class="nx">value</span> <span class="p">=</span> <span class="kc">false</span>
  <span class="p">}</span>
  <span class="nx">set</span> <span class="p">{</span>
    <span class="nx">name</span>  <span class="p">=</span> <span class="s2">"gitlab.grafana.install"</span>
    <span class="nx">value</span> <span class="p">=</span> <span class="kc">false</span>
  <span class="p">}</span>
  <span class="nx">set</span> <span class="p">{</span>
    <span class="nx">name</span>  <span class="p">=</span> <span class="s2">"nginx-ingress.enabled"</span>
    <span class="nx">value</span> <span class="p">=</span> <span class="kc">false</span>
  <span class="p">}</span>
  <span class="nx">set</span> <span class="p">{</span>
    <span class="nx">name</span>  <span class="p">=</span> <span class="s2">"gitlab-runner.enabled"</span>
    <span class="nx">value</span> <span class="p">=</span> <span class="kc">false</span>
  <span class="p">}</span>
  <span class="nx">set</span> <span class="p">{</span>
    <span class="nx">name</span>  <span class="p">=</span> <span class="s2">"global.hosts.domain"</span>
    <span class="nx">value</span> <span class="p">=</span> <span class="kd">var</span><span class="p">.</span><span class="nx">domain</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="使用-kubectl-安装组件">使用 kubectl 安装组件</h2>

<p>下面的示例安装了 argocd，使用了官网的默认安装方法，使用 kubectl 直接执行 yaml 文件。</p>

<div class="language-terraform highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">variable</span> <span class="s2">"namespace"</span> <span class="p">{</span>
  <span class="nx">type</span>    <span class="p">=</span> <span class="nx">string</span>
  <span class="nx">default</span> <span class="p">=</span> <span class="s2">"argocd"</span>
<span class="p">}</span>

<span class="k">resource</span> <span class="s2">"kubectl_manifest"</span> <span class="s2">"argocd_namepsace"</span> <span class="p">{</span>
  <span class="nx">yaml_body</span> <span class="p">=</span> <span class="o">&lt;&lt;</span><span class="no">YAML</span><span class="sh">
apiVersion: v1
kind: Namespace
metadata:
  name: ${var.namespace}
</span><span class="no">YAML
</span><span class="p">}</span>
</code></pre></div></div>

<p>在集群内创建了一个 namespace。</p>

<p>由于 kubectl_manifest 只能执行单资源，象 argocd 给出的 yaml 文件里，包含了很多的资源，此时需要使用 <code class="language-plaintext highlighter-rouge">kubectl_file_documents</code> 将一大段资源解构成单个资源数组。</p>

<div class="language-terraform highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">data</span> <span class="s2">"http"</span> <span class="s2">"argocd_yaml"</span> <span class="p">{</span>
  <span class="nx">url</span> <span class="p">=</span> <span class="s2">"https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml"</span>
<span class="p">}</span>

<span class="k">data</span> <span class="s2">"kubectl_file_documents"</span> <span class="s2">"argocd_docs"</span> <span class="p">{</span>
  <span class="nx">content</span> <span class="p">=</span> <span class="k">data</span><span class="p">.</span><span class="nx">http</span><span class="p">.</span><span class="nx">argocd_yaml</span><span class="p">.</span><span class="nx">response_body</span>
<span class="p">}</span>
</code></pre></div></div>

<p>然后循环执行即可：</p>

<div class="language-terraform highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">resource</span> <span class="s2">"kubectl_manifest"</span> <span class="s2">"argocd"</span> <span class="p">{</span>
  <span class="nx">for_each</span>           <span class="p">=</span> <span class="k">data</span><span class="p">.</span><span class="nx">kubectl_file_documents</span><span class="p">.</span><span class="nx">argocd_docs</span><span class="p">.</span><span class="nx">manifests</span>
  <span class="nx">yaml_body</span>          <span class="p">=</span> <span class="nx">each</span><span class="p">.</span><span class="nx">value</span>
  <span class="nx">override_namespace</span> <span class="p">=</span> <span class="kd">var</span><span class="p">.</span><span class="nx">namespace</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name>啤酒云</name></author><category term="iac," /><category term="aws," /><category term="container" /><category term="iac," /><category term="container," /><category term="aws," /><category term="terraform" /><summary type="html"><![CDATA[在已经开通了 EKS 的情况下，使用 terraform 给 EKS 集群安装组件。]]></summary></entry><entry><title type="html">在 K8S 中配置域名解析</title><link href="https://youbug.cn/2022/12/dns-in-k8s.html" rel="alternate" type="text/html" title="在 K8S 中配置域名解析" /><published>2022-12-06T08:09:00+00:00</published><updated>2022-12-06T08:09:00+00:00</updated><id>https://youbug.cn/2022/12/dns-in-k8s</id><content type="html" xml:base="https://youbug.cn/2022/12/dns-in-k8s.html"><![CDATA[<p>在应用开发中，我们不应把远程服务的 ip 硬编码到应用中。有些同学习惯使用域名来标定远程服务，通过修改解析，来区分开发测试和生产环境，这是一个挺好的习惯。在 k8s 系统中，我们使用服务名来调用服务，并通过 coredns 来进行解析。但那些集群外的服务，并且已经被硬编码的域名如何访问呢？</p>

<p>此文拷贝自自己的旧文章，为防止知识过期，在 aws eks 上重新验证成功。</p>

<h2 id="方法1修改容器实例的-hosts">方法1：修改容器实例的 hosts</h2>

<p>设想：把 hosts 文件内容存储在 ConfigMap 中，通过 volume 绑定到 /etc/hosts。但很不幸，/etc/hosts 被 k8s 征用了，无法修改。</p>

<p>但 K8S 给我们提供了 hostAliases 来解决此问题。</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">apps/v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Deployment</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">hosts-append</span>
  <span class="na">labels</span><span class="pi">:</span> 
    <span class="na">app</span><span class="pi">:</span> <span class="s">hosts-append</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">replicas</span><span class="pi">:</span> <span class="m">1</span>
  <span class="na">selector</span><span class="pi">:</span>
    <span class="na">matchLabels</span><span class="pi">:</span>
      <span class="na">app</span><span class="pi">:</span> <span class="s">hosts-append</span>
  <span class="na">template</span><span class="pi">:</span>
    <span class="na">metadata</span><span class="pi">:</span>
      <span class="na">labels</span><span class="pi">:</span>
        <span class="na">app</span><span class="pi">:</span> <span class="s">hosts-append</span>
    <span class="na">spec</span><span class="pi">:</span>
      <span class="na">hostAliases</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="na">ip</span><span class="pi">:</span> <span class="s2">"</span><span class="s">127.0.0.1"</span>
        <span class="na">hostnames</span><span class="pi">:</span>
        <span class="pi">-</span> <span class="s2">"</span><span class="s">foo.local"</span>
        <span class="pi">-</span> <span class="s2">"</span><span class="s">bar.local"</span>
      <span class="pi">-</span> <span class="na">ip</span><span class="pi">:</span> <span class="s2">"</span><span class="s">10.1.2.3"</span>
        <span class="na">hostnames</span><span class="pi">:</span>
        <span class="pi">-</span> <span class="s2">"</span><span class="s">foo.remote"</span>
        <span class="pi">-</span> <span class="s2">"</span><span class="s">bar.remote"</span>
      <span class="na">containers</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="na">image</span><span class="pi">:</span> <span class="s">nginx:alpine</span>
        <span class="na">name</span><span class="pi">:</span> <span class="s">hosts-append</span>
        <span class="na">ports</span><span class="pi">:</span>
        <span class="pi">-</span> <span class="na">containerPort</span><span class="pi">:</span> <span class="m">80</span>
          <span class="na">protocol</span><span class="pi">:</span> <span class="s">TCP</span>
</code></pre></div></div>

<p>部署后，pod 里面的 hosts 文件已经追加了解析记录。查看结果如下：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl <span class="nb">exec </span>hosts-append-&lt;your-id&gt; <span class="nt">--</span> <span class="nb">cat</span> /etc/hosts
</code></pre></div></div>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Kubernetes-managed hosts file.</span>
127.0.0.1 localhost
::1 localhost ip6-localhost ip6-loopback
fe00::0 ip6-localnet
fe00::0 ip6-mcastprefix
fe00::1 ip6-allnodes
fe00::2 ip6-allrouters
10.10.6.23 hosts-append-6f96d5449f-rldxr

<span class="c"># Entries added by HostAliases.</span>
127.0.0.1 foo.local bar.local
10.1.2.3 foo.remote bar.remote
</code></pre></div></div>

<p>此方法的缺点是：不同环境下的域名映射是不一样的，必须为环境编写不同的 yaml 部署文件，并且给每一个 deployment 编写 hostAliases 会有点“侵入”。</p>

<h2 id="方法2使用内置-coredns-解析">方法2：使用内置 coredns 解析</h2>

<p>K8S 内部默认已经安装了 coredns 服务，可以通过修改 coredns 的配置来达到内部解析的目的。</p>

<p>coredns 的配置写在了 configmap 的 kube-system 命名空间下的 coredns 配置节点了。只需要修改 hosts 配置节点内容就好。</p>

<p>编辑他：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl edit cm <span class="nt">-n</span> kube-system coredns
</code></pre></div></div>

<p>配置示例(其中 hosts 节点是自定义的解析节点，如果没有 hosts 节点，可以增加一个)：</p>

<pre><code class="language-configmap">    .:53 {
        errors
        health
        kubernetes cluster.local. in-addr.arpa ip6.arpa {
            pods insecure
            upstream
            fallthrough in-addr.arpa ip6.arpa
        }
        hosts {
          127.0.0.1 foo.local
          8.8.8.8 foo.remote
          fallthrough
        }
        prometheus :9153
        proxy . /etc/resolv.conf
        cache 30
        reload
        loadbalance
    }
</code></pre>

<p>修改完成后，要等等。配置下发完成即可生效。可以进入 pod 内部 ping 一下域名看看。</p>

<h2 id="方法3-使用自定义域名服务器解析">方法3. 使用自定义域名服务器解析</h2>

<p>在 coredns 的 ConfigMap 中，还可以自定义 name server，配置类似：</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">ConfigMap</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">annotations</span><span class="pi">:</span>
  <span class="na">labels</span><span class="pi">:</span>
    <span class="na">eks.amazonaws.com/component</span><span class="pi">:</span> <span class="s">coredns</span>
    <span class="na">k8s-app</span><span class="pi">:</span> <span class="s">kube-dns</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">coredns</span>
  <span class="na">namespace</span><span class="pi">:</span> <span class="s">kube-system</span>
<span class="na">data</span><span class="pi">:</span>
  <span class="na">Corefile</span><span class="pi">:</span> <span class="pi">|</span>
    <span class="s">.:53 {</span>
        <span class="s">errors</span>
        <span class="s">health</span>
        <span class="s">kubernetes cluster.local in-addr.arpa ip6.arpa {</span>
          <span class="s">pods insecure</span>
          <span class="s">fallthrough in-addr.arpa ip6.arpa</span>
        <span class="s">}</span>
        <span class="s">prometheus :9153</span>
        <span class="s">forward . /etc/resolv.conf</span>
        <span class="s">cache 30</span>
        <span class="s">loop</span>
        <span class="s">reload</span>
        <span class="s">loadbalance</span>
    <span class="s">}</span>
    <span class="s">domain-name:53 {</span>
        <span class="s">errors</span>
        <span class="s">cache 30</span>
        <span class="s">forward . custom-dns-server</span>
        <span class="s">reload</span>
    <span class="s">}</span>
</code></pre></div></div>

<ul>
  <li>在 <code class="language-plaintext highlighter-rouge">domain-name:53</code> 节点中可以定义 name server</li>
  <li>如果没有这个节点，可以增加一个，此节点与 <code class="language-plaintext highlighter-rouge">.:53</code> 平级。</li>
</ul>

<p>下面以 aws route53 为例进行测试。</p>

<p>首选进入 route53 控制台，进入 <a href="https://console.aws.amazon.com/route53/v2/hostedzones#CreateHostedZone">创建托管区</a>。如图：</p>

<p><img src="/assets/posts/container/create-dns-zone.png" alt="Create 53 Private Zone" /></p>

<p>创建完成可以看到解析记录里 name server，地址类似如下：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ns-1536.awsdns-00.co.uk.
ns-0.awsdns-00.com.
ns-1024.awsdns-00.org.
ns-512.awsdns-00.net.
</code></pre></div></div>

<p>并添加一个新解析 A 记录，如下图：</p>

<p><img src="/assets/posts/container/dns-res.png" alt="DNS result" /></p>

<p>编辑 ConfigMap，参考上面的配置，修改 K8S/EKS 的 name server</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl edit cm <span class="nt">-n</span> kube-system coredns
</code></pre></div></div>

<p>在 <code class="language-plaintext highlighter-rouge">domain-name:53</code> 节点设置 <code class="language-plaintext highlighter-rouge">forward . ns-1536.awsdns-00.co.uk.</code> 即可。</p>

<p>设置完成，进入 EKS 的 任意 pod 测试，ping 或者 dig 一下，结果如下：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># dig www.youbug.cn</span>

<span class="p">;</span> &lt;&lt;<span class="o">&gt;&gt;</span> DiG 9.16.33-Debian &lt;&lt;<span class="o">&gt;&gt;</span> www.youbug.cn
<span class="p">;;</span> global options: +cmd
<span class="p">;;</span> Got answer:
<span class="p">;;</span> -&gt;&gt;HEADER<span class="o">&lt;&lt;-</span> <span class="no">opcode</span><span class="sh">: QUERY, status: NOERROR, id: 42026
;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1

;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags:; udp: 4096
; COOKIE: d032981648385382 (echoed)
;; QUESTION SECTION:
;www.youbug.cn.   IN A

;; ANSWER SECTION:
www.youbug.cn.  30 IN A 192.168.0.1

;; Query time: 0 msec
;; SERVER: 172.20.0.10#53(172.20.0.10)
;; WHEN: Wed Dec 07 02:39:49 UTC 2022
;; MSG SIZE  rcvd: 83

</span></code></pre></div></div>

<p>可以看到已经生效了。</p>

<p>其他云厂商的或者自建域名服务器可以使用类似方法，不一一赘述了。</p>

<h2 id="使用场景总结">使用场景总结</h2>

<table>
  <tbody>
    <tr>
      <td><strong>名称</strong></td>
      <td><strong>方法</strong></td>
      <td><strong>适用场景</strong></td>
    </tr>
    <tr>
      <td>hostAliases</td>
      <td>修改 pod 的 hosts 配置</td>
      <td>K8S 集群内部分 workloads 需要单独解析。开发者临时测试没有 ConfigMap 权限等。A/B Test。</td>
    </tr>
    <tr>
      <td>coredns 直接解析</td>
      <td>修改 ConfigMap 直接解析</td>
      <td>完整的 K8S 开发测试环境，UAT 环境等</td>
    </tr>
    <tr>
      <td>自定义 dns server</td>
      <td>修改 ConfigMap 配置以使用自定义域名服务器</td>
      <td>多 K8S 集群，有非 K8S 负载，VPC 范围解析</td>
    </tr>
  </tbody>
</table>

<p>当然，更好的做法是把 <strong>配置文件与应用解耦，所有的配置，包括远程服务的域名或 ip 都可以被远程修改</strong>。</p>]]></content><author><name>啤酒云</name></author><category term="container," /><category term="aws" /><category term="容器," /><category term="aws," /><category term="dns," /><category term="kubernetes" /><summary type="html"><![CDATA[在应用开发中，我们不应把远程服务的 ip 硬编码到应用中。有些同学习惯使用域名来标定远程服务，通过修改解析，来区分开发测试和生产环境，这是一个挺好的习惯。在 k8s 系统中，我们使用服务名来调用服务，并通过 coredns 来进行解析。但那些集群外的服务，并且已经被硬编码的域名如何访问呢？]]></summary></entry><entry><title type="html">容器 DevOps: Argo CD 入门</title><link href="https://youbug.cn/2022/12/argocd-start.html" rel="alternate" type="text/html" title="容器 DevOps: Argo CD 入门" /><published>2022-12-05T08:20:01+00:00</published><updated>2022-12-05T08:20:01+00:00</updated><id>https://youbug.cn/2022/12/argocd-start</id><content type="html" xml:base="https://youbug.cn/2022/12/argocd-start.html"><![CDATA[<p>在 GitOps 模式下，当 CI 完成容器打包后，还需要将部署脚本的容器版本号更新到 git 仓库，接下来的工作就可以交给容器内的 CD 来干了。这有效解耦了 CI/CD 过程。这个模式非常适合多云多集群的应用部署，以及有效协调运维部门和业务研发部门的工作。</p>

<h2 id="gitops-和-argo-cd">GitOps 和 Argo CD</h2>

<p>GitOps 的基本概念:</p>

<p>参考这个：<a href="https://www.weave.works/technologies/gitops/">https://www.weave.works/technologies/gitops/</a>。大概意思是：将 CI/CD 整个过程作为代码，存储在 git 仓库，基于 git 仓库中的代码和动作作为 CI/CD 的依据。CI/CD 系统会根据变动触发构建或部署过程。</p>

<p>Argo CD 的定义是：</p>

<p>在 Kubernetes 中声明式 GitOps 的持续交付工具。Argo CD is a declarative, GitOps continuous delivery tool for Kubernetes.</p>

<p>下面的示例中，将演示一下一个 CD 的过程。</p>

<h2 id="简要安装测试模式">简要安装(测试模式)</h2>

<p>安装非常简单，过程如下：</p>

<p>创建 命名空间：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl create namespace argocd
</code></pre></div></div>

<p>安装：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl apply <span class="nt">-n</span> argocd <span class="nt">-f</span> https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml
</code></pre></div></div>

<p>这样就可以了。</p>

<p>使用下面的命令验证安装结果：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl get po <span class="nt">-nargocd</span>
</code></pre></div></div>

<p>显示结果如下：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>NAME                                                READY   STATUS    RESTARTS      AGE
argocd-application-controller-0                     1/1     Running   0             64s
argocd-applicationset-controller-6779fd5cf5-ct5ck   1/1     Running   0             78s
argocd-dex-server-68f86575b6-xcrx6                  1/1     Running   2 <span class="o">(</span>65s ago<span class="o">)</span>   76s
argocd-notifications-controller-769b876844-wj6ck    1/1     Running   0             74s
argocd-redis-547f5d94cd-9rb94                       1/1     Running   0             72s
argocd-repo-server-77b686784d-2bkjp                 1/1     Running   0             69s
argocd-server-6f497ddb95-l4sxv                      1/1     Running   0             66s
</code></pre></div></div>

<p>如果在生产环境，请参考高可用模式安装: <a href="https://argo-cd.readthedocs.io/en/stable/operator-manual/installation/">https://argo-cd.readthedocs.io/en/stable/operator-manual/installation/</a></p>

<h2 id="部署第一个-cd-应用">部署第一个 CD 应用</h2>

<p>请 clone 这个 github 仓库 ，这里包含了应用部署脚本和 Argo CD 的脚本。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git clone https://github.com/cloudbeer/cd-script.git
</code></pre></div></div>

<p>下面我们尝试使用 argocd 持续升级 nginx 应用。</p>

<p>为此，我们需要编写 nginx 的 k8s 部署脚本。</p>

<h3 id="代码说明">代码说明</h3>

<p>部署 nginx 应用：deployment.yaml</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">apps/v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Deployment</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">nginx</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">replicas</span><span class="pi">:</span> <span class="m">1</span>
  <span class="na">selector</span><span class="pi">:</span>
    <span class="na">matchLabels</span><span class="pi">:</span>
      <span class="na">app</span><span class="pi">:</span> <span class="s">nginx</span>
  <span class="na">template</span><span class="pi">:</span>
    <span class="na">metadata</span><span class="pi">:</span>
      <span class="na">labels</span><span class="pi">:</span>
        <span class="na">app</span><span class="pi">:</span> <span class="s">nginx</span>
    <span class="na">spec</span><span class="pi">:</span>
      <span class="na">containers</span><span class="pi">:</span>
        <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">nginx</span>
          <span class="na">image</span><span class="pi">:</span> <span class="s">nginx</span>
          <span class="na">ports</span><span class="pi">:</span>
            <span class="pi">-</span> <span class="na">containerPort</span><span class="pi">:</span> <span class="m">80</span>
              <span class="na">protocol</span><span class="pi">:</span> <span class="s">TCP</span>
</code></pre></div></div>

<p>暴露 nginx 服务: service.yaml</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Service</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">nginx</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">ports</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">http-nginx</span>
      <span class="na">port</span><span class="pi">:</span> <span class="m">80</span>
  <span class="na">selector</span><span class="pi">:</span>
    <span class="na">app</span><span class="pi">:</span> <span class="s">nginx</span>
</code></pre></div></div>

<p>kustomization.yaml</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">kustomize.config.k8s.io/v1beta1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Kustomization</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">nginx</span>
<span class="na">commonLabels</span><span class="pi">:</span>
  <span class="na">app</span><span class="pi">:</span> <span class="s">nginx</span>
<span class="na">resources</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="s">deployment.yaml</span>
  <span class="pi">-</span> <span class="s">service.yaml</span>
<span class="na">images</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">nginx</span>
    <span class="na">newTag</span><span class="pi">:</span> <span class="s2">"</span><span class="s">1.16"</span>
</code></pre></div></div>

<p>上面编写的部署脚本，现在无须执行，先放到 git 仓库，
本示例的代码位于： <a href="https://github.com/cloudbeer/cd-script/tree/main/nginx">https://github.com/cloudbeer/cd-script/tree/main/nginx</a></p>

<p>现在编写 Argo CD 的应用，此部分可以在 Web 界面配置（稍后我们去查看 Web UI），
Argo CD 的 Application 其实是在 K8S 中以 CRD 形式存在，就象下面的代码：</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">argoproj.io/v1alpha1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Application</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">nginx</span>
  <span class="na">namespace</span><span class="pi">:</span> <span class="s">default</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">project</span><span class="pi">:</span> <span class="s">default</span>
  <span class="na">destination</span><span class="pi">:</span>
    <span class="na">namespace</span><span class="pi">:</span> <span class="s">default</span>
    <span class="na">server</span><span class="pi">:</span> <span class="s2">"</span><span class="s">https://kubernetes.default.svc"</span>
  <span class="na">source</span><span class="pi">:</span>
    <span class="na">repoURL</span><span class="pi">:</span> <span class="s2">"</span><span class="s">https://github.com/cloudbeer/cd-script.git"</span>
    <span class="na">targetRevision</span><span class="pi">:</span> <span class="s">HEAD</span>
    <span class="na">path</span><span class="pi">:</span> <span class="s">nginx</span>
  <span class="na">syncPolicy</span><span class="pi">:</span>
    <span class="na">automated</span><span class="pi">:</span> 
      <span class="na">prune</span><span class="pi">:</span> <span class="no">true</span>
      <span class="na">selfHeal</span><span class="pi">:</span> <span class="no">true</span>
</code></pre></div></div>

<p>拆解一下上面的代码：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">kind: Application</code> 是 Argo CD 扩展的 CRD。</li>
  <li><code class="language-plaintext highlighter-rouge">project: default</code> project 是 argocde 的逻辑组织单元，他可以按照 project 去分类维护 Application。</li>
  <li><code class="language-plaintext highlighter-rouge">destination</code> 部分描述了我们需要部署的目标为当前集群的 default 命名空间。(如果部署到其他命名空间，请先创建 ns，或者在 yaml 指定)。</li>
  <li><code class="language-plaintext highlighter-rouge">source</code> 表示部署文件所在的 git 地址。本例中是这个 git 仓库的 nginx 目录。</li>
  <li><code class="language-plaintext highlighter-rouge">syncPolicy</code> 是同步策略，自动策略中包括开关：
    <ul>
      <li><code class="language-plaintext highlighter-rouge">automated.prune</code>: 字面意思是 修剪，如果设置为 true，他可以允许删除 yaml 里没有的资源以保持部署与描述一致。</li>
      <li><code class="language-plaintext highlighter-rouge">automated.selfHeal</code>: 设置为 true 的时候，Argo CD 会定期检查当前集群的状态和 yaml 描述是否一致，如果不一致，则会触发部署。</li>
    </ul>
  </li>
</ul>

<h3 id="部署">部署</h3>

<p>现在请将上述 Application 部署到 K8S 集群 中。</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s">kubectl apply -f applications/nginx.yaml</span>
</code></pre></div></div>

<p>检查部署结果:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s">kubectl get app -nargocd</span>
</code></pre></div></div>

<p>可以看到应用已经同步了：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>NAME    SYNC STATUS   HEALTH STATUS
nginx   Synced        Healthy
</code></pre></div></div>

<p>同时检查一下业务应用部署结果：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl get po <span class="nt">-ndefault</span>
</code></pre></div></div>

<p>查看一下当前部署的版本：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl get deploy nginx <span class="nt">-oyaml</span> | <span class="nb">grep </span>image:
</code></pre></div></div>

<p>现在我们尝试更新一下 nginx 的版本号，修改一下 kustomization.yaml 文件中的版本号。然后持续观察部署结果。</p>

<blockquote>
  <p>通常修改 kustomization 的动作是由 CI 系统来完成的，在上一章文章 <a href="/2022/12/k8s-devops-gitlab-ci.html">Gitlab CI</a> 里我们已经演示了如何 修改  kustomization.yaml 这个文件了。</p>
</blockquote>

<h3 id="使用-web-ui">使用 Web UI</h3>

<p>先查询一下密码：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl <span class="nt">-n</span> argocd get secret argocd-initial-admin-secret <span class="nt">-o</span> <span class="nv">jsonpath</span><span class="o">=</span><span class="s2">"{.data.password}"</span> | <span class="nb">base64</span> <span class="nt">-d</span><span class="p">;</span> <span class="nb">echo</span>
</code></pre></div></div>

<p>映射端口：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl port-forward svc/argocd-server <span class="nt">-n</span> argocd 8080:80
</code></pre></div></div>

<p>然后访问 <a href="http://localhost:8080">http://localhost:8080</a>，登录用户名 admin，密码为刚刚查询的密码。</p>

<p>登录进去之后，就可以看到 Web 界面了，在 Web 里，可以看到很多绚烂的内容。</p>]]></content><author><name>啤酒云</name></author><category term="devops," /><category term="container" /><category term="gitops," /><category term="argocd" /><summary type="html"><![CDATA[在 GitOps 模式下，当 CI 完成容器打包后，还需要将部署脚本的容器版本号更新到 git 仓库，接下来的工作就可以交给容器内的 CD 来干了。这有效解耦了 CI/CD 过程。这个模式非常适合多云多集群的应用部署，以及有效协调运维部门和业务研发部门的工作。]]></summary></entry><entry><title type="html">Github pages jekyll 插件不支持怎么办</title><link href="https://youbug.cn/2022/12/github-pages-not-support.html" rel="alternate" type="text/html" title="Github pages jekyll 插件不支持怎么办" /><published>2022-12-04T14:13:33+00:00</published><updated>2022-12-04T14:13:33+00:00</updated><id>https://youbug.cn/2022/12/github-pages-not-support</id><content type="html" xml:base="https://youbug.cn/2022/12/github-pages-not-support.html"><![CDATA[<p>花了一下午的时间，将博客的分页，分类功能加上了。结果发现 github pages 不支持，还不能自己安装 jekyll 的插件。然后头大了。</p>

<p>这片文章记录了如何解决这个麻烦。</p>

<h2 id="github-pages-插件别瞎用">github pages 插件别瞎用</h2>

<p>当你觉得你完美解决了写博客的问题的时候，就发现问题了。</p>

<p>下午找到一个不错的分页插件：jekyll-paginate-v2， 搞定了 分页，tags 功能，本地渲染出来很不错，甚合我意。</p>

<p>推送之后，发现了蛋疼的事情：所有的列表页面都是空的。</p>

<p>Actions 也都正常，调查半天才发现，github pages 不支持 jekyll-paginate-v2。</p>

<p>这是他支持的：<a href="https://pages.github.com/versions/">https://pages.github.com/versions/</a></p>

<h2 id="circleci-集成">circleci 集成</h2>

<p>那只能用第三方 CI 工具了。用 gitlab ci 肯定是可以的。</p>

<p>现在试试 circleci。 下面记录了过程：</p>

<h3 id="step-1-创建新分支">step 1. 创建新分支</h3>

<p>创建 cloudbeer.github.io 新分支：soruce。</p>

<h3 id="step-2-添加-circleci-config-文件">step 2. 添加 circleci config 文件</h3>

<p>在新分支里添加文件：<code class="language-plaintext highlighter-rouge">.circleci/config.yml</code>，内容如下：</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="na">version</span><span class="pi">:</span> <span class="m">2</span>
<span class="na">jobs</span><span class="pi">:</span>
  <span class="na">deploy</span><span class="pi">:</span>
    <span class="na">docker</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="na">image</span><span class="pi">:</span> <span class="s">cimg/ruby:2.7.4</span>
        <span class="na">environment</span><span class="pi">:</span>
          <span class="na">USER_NAME</span><span class="pi">:</span> <span class="s">cloudbeer</span>
          <span class="na">USER_EMAIL</span><span class="pi">:</span> <span class="s">cloudbeer@gmail.com</span>
    <span class="na">steps</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">checkout</span>
      <span class="pi">-</span> <span class="na">restore_cache</span><span class="pi">:</span>
          <span class="na">keys</span><span class="pi">:</span>
            <span class="pi">-</span> <span class="s">rubygems-v1-{{ checksum "Gemfile.lock" }}</span>
            <span class="pi">-</span> <span class="s">rubygems-v1-fallback</span>
      <span class="pi">-</span> <span class="na">run</span><span class="pi">:</span>
          <span class="na">name</span><span class="pi">:</span> <span class="s">Bundle Install</span>
          <span class="na">command</span><span class="pi">:</span> <span class="s">bundle install</span>
      <span class="pi">-</span> <span class="na">save_cache</span><span class="pi">:</span>
          <span class="na">paths</span><span class="pi">:</span>
            <span class="pi">-</span> <span class="s">vendor/bundle</span>
          <span class="na">key</span><span class="pi">:</span> <span class="s">rubygems-v1-{{ checksum "Gemfile.lock" }}</span>
      <span class="pi">-</span> <span class="na">run</span><span class="pi">:</span> 
          <span class="na">name</span><span class="pi">:</span> <span class="s">Jekyll Build</span>
          <span class="na">command</span><span class="pi">:</span> <span class="s">JEKYLL_ENV=production bundle exec jekyll build</span>
      <span class="pi">-</span> <span class="na">deploy</span><span class="pi">:</span>
          <span class="na">name</span><span class="pi">:</span> <span class="s">Deploy Release to GitHub</span>
          <span class="na">command</span><span class="pi">:</span> <span class="pi">|</span>
            <span class="s">if [ $CIRCLE_BRANCH == 'source' ]; then</span>
              <span class="s">bash .circleci/deploy.sh</span>
            <span class="s">fi</span>
<span class="na">workflows</span><span class="pi">:</span>
  <span class="na">version</span><span class="pi">:</span> <span class="m">2</span>
  <span class="na">build</span><span class="pi">:</span>
    <span class="na">jobs</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="na">deploy</span><span class="pi">:</span>
          <span class="na">filters</span><span class="pi">:</span>
            <span class="na">branches</span><span class="pi">:</span>
              <span class="na">only</span><span class="pi">:</span> 
                <span class="pi">-</span> <span class="s">source</span>

</code></pre></div></div>

<p>代码的意思大概是：</p>

<ul>
  <li>使用 ruby 镜像，安装依赖，build</li>
  <li>然后调用 deploy 脚本</li>
</ul>

<h3 id="step-3-doploy-脚本">step 3. doploy 脚本</h3>

<p>添加脚本 <code class="language-plaintext highlighter-rouge">.circleci/deploy.sh</code>，内容如下：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git config user.name <span class="s2">"</span><span class="nv">$USER_NAME</span><span class="s2">"</span>
git config user.email <span class="s2">"</span><span class="nv">$USER_EMAIL</span><span class="s2">"</span>

git checkout main
git pull origin main

find <span class="nb">.</span> <span class="nt">-maxdepth</span> 1 <span class="o">!</span> <span class="nt">-name</span> <span class="s1">'_site'</span> <span class="o">!</span> <span class="nt">-name</span> <span class="s1">'.git'</span> <span class="o">!</span> <span class="nt">-name</span> <span class="s1">'.gitignore'</span> <span class="o">!</span> <span class="nt">-name</span> <span class="s1">'.circleci'</span> <span class="nt">-exec</span> <span class="nb">rm</span> <span class="nt">-rf</span> <span class="o">{}</span> <span class="se">\;</span>
<span class="nb">mv </span>_site/<span class="k">*</span> <span class="nb">.</span>
<span class="nb">rm</span> <span class="nt">-R</span> _site/

git add <span class="nt">-fA</span>
git commit <span class="nt">--allow-empty</span> <span class="nt">-m</span> <span class="s2">"</span><span class="si">$(</span>git log <span class="nb">source</span> <span class="nt">-1</span> <span class="nt">--pretty</span><span class="o">=</span>%B<span class="si">)</span><span class="s2">"</span>

git remote set-url origin https://cloudbeer:<span class="k">${</span><span class="nv">GITHUB_PWD</span><span class="k">}</span>@github.com/cloudbeer/cloudbeer.github.io.git

git push <span class="nt">-f</span> origin main

<span class="nb">echo</span> <span class="s2">"deployed successfully"</span>
</code></pre></div></div>

<p>代码的大概意思是：</p>

<ul>
  <li>把分支切到 main，把编译目标 _site 目录里面的文件拷贝到根目录。</li>
  <li>把代码推回去。</li>
  <li>github pages 里设置的是 main 分支的 / 目录，此时 main 下面都是纯 html 页面。</li>
  <li>稍等一会儿 github pages 发布完成就可以看到结果了。</li>
</ul>

<p>上面的代码有个地方需要改进，就是这行：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git remote set-url origin https://cloudbeer:<span class="k">${</span><span class="nv">GITHUB_PWD</span><span class="k">}</span>@github.com/cloudbeer/cloudbeer.github.io.git
</code></pre></div></div>

<p>推送的时候发现没有权限，先用这个土办法了。这里的 <a href="https://github.com/settings/tokens">GITHUB_PWD 需要去生产</a>，我把申请到的结果存入了 circleci 的环境变量里。</p>

<p>还需要改进的有：</p>

<p>github 在发现有新的 push 之后 还是在运行 jekyll build，在此种情况下，应该直接部署就好。后面再看看咋搞。</p>

<h2 id="github-pages-随便搞">github pages 随便搞</h2>

<p>了解了 github pages 的规则，就可以用任意支持 markdown 的框架来做你的博客了，前提是他静态页面生产器。</p>

<p>发现 circleci 在第二次 build 的时候很快啊，比 gitlab 快很多。可能是一个默认缓存，一个没默认缓存的缘故吧。</p>

<hr />

<p>本文代码参考了如下俩：</p>

<p><a href="https://jasonthai.me/blog/2019/07/22/how-to-deploy-a-github-page-using-circleci-20-custom-jekyll-gems/">How to Deploy to Github Pages Using CircleCI 2.0 + Custom Jekyll Dependencies
</a></p>

<p><a href="https://jekyllrb.com/docs/continuous-integration/circleci/">Jekyll - CircleCI</a></p>]]></content><author><name>啤酒云</name></author><category term="devops," /><category term="tucao," /><category term="circleci," /><category term="github," /><category term="jekyll" /><summary type="html"><![CDATA[花了一下午的时间，将博客的分页，分类功能加上了。结果发现 github pages 不支持，还不能自己安装 jekyll 的插件。然后头大了。]]></summary></entry><entry><title type="html">AWS CDK 入门：Hello World</title><link href="https://youbug.cn/2022/12/cdk-start-hello-world.html" rel="alternate" type="text/html" title="AWS CDK 入门：Hello World" /><published>2022-12-04T11:54:44+00:00</published><updated>2022-12-04T11:54:44+00:00</updated><id>https://youbug.cn/2022/12/cdk-start-hello-world</id><content type="html" xml:base="https://youbug.cn/2022/12/cdk-start-hello-world.html"><![CDATA[<p>本文是 AWS CDK 入门教程，将利用 “渐进” 模式 使用 AWS CDK 生产一个生产可用的 EKS 集群。本文是上半部分，CDK 入门知识。</p>

<h2 id="iac-和-cdk-简介">IaC 和 CDK 简介</h2>

<h3 id="什么是-iac">什么是 IaC？</h3>

<p>这段来自：<a href="https://www.redhat.com/zh/topics/automation/what-is-infrastructure-as-code-iac">https://www.redhat.com/zh/topics/automation/what-is-infrastructure-as-code-iac</a></p>

<blockquote>
  <p>基础设施即代码（IaC）是通过代码而非手动流程来管理和置备基础设施的方法。</p>

  <p>利用 IaC 我们可以创建包含基础设施规范的配置文件，从而便于编辑和分发配置。此外，它还可确保每次置备的环境都完全相同。通过对配置规范进行整理和记录，IaC 有助于实现配置管理，并避免发生未记录的临时配置更改。</p>

  <p>版本控制是 IaC 的一个重要组成部分，就像其他任何软件源代码文件一样，配置文件也应该在源代码控制之下。以基础设施即代码方式部署还意味着您可以将基础架构划分为若干模块化组件，它们可通过自动化以不同的方式进行组合。</p>

  <p>借助 IaC 实现基础架构置备的自动化，意味着开发人员无需再在每次开发或部署应用时手动置备和管理服务器、操作系统、存储及其他基础架构组件。对基础架构编码即可创建一个置备用的模板，尽管置备过程仍然可以手动完成，但也可以由自动化工具（例如红帽® Ansible® 自动化平台）为您代劳。</p>
</blockquote>

<p>简要来说就是：使用描述性的代码管理您的基础设施。</p>

<h3 id="什么是-cdk">什么是 CDK？</h3>

<p>这段来自：<a href="https://aws.amazon.com/cn/getting-started/guides/setup-cdk/">https://aws.amazon.com/cn/getting-started/guides/setup-cdk/</a></p>

<blockquote>
  <p>AWS CDK 是一个开源软件开发框架，可让您使用熟悉的编程语言 (如 JavaScript、TypeScript、Python、Java、C# 和 Go) 定义云应用程序资源。您编写的代码转换为 CloudFormation (CFN) 模板，可使用 <a href="https://aws.amazon.com/cn/cloudformation/">AWS CloudFormation</a> 创建基础设施。</p>
</blockquote>

<p>这个也总结一下：CDK 就是 AWS 的 IaC，他依赖 Cloudformation，可以用常用的语言来描述您的基础设施。</p>

<h2 id="安装和设置-aws-cdk">安装和设置 AWS CDK</h2>

<p>我习惯使用命令行的方式运行，如 <code class="language-plaintext highlighter-rouge">cdk deploy</code>。cdk 这个命令其实是一个 nodejs 程序。</p>

<p>nodejs 安装就不说了，现在国内有很多开源镜像，如：<a href="https://mirrors.tuna.tsinghua.edu.cn/nodejs-release">https://mirrors.tuna.tsinghua.edu.cn/nodejs-release</a>，请安装版本 &gt;= 10.3.0 的。</p>

<p>nodejs 安装完成后，就可以安装 cdk 命令行：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>npm i <span class="nt">-g</span> aws-cdk
</code></pre></div></div>

<p>默认安装完成后 CDK 就是全局命令行了。</p>

<p>CDK 同时要依赖 AWS CLI 以及 AWS 凭证。</p>

<p>安装 AWS CLI 参考：<a href="https://docs.aws.amazon.com/zh_cn/cli/latest/userguide/getting-started-install.html">https://docs.aws.amazon.com/zh_cn/cli/latest/userguide/getting-started-install.html</a></p>

<p>在开发环境配置凭证：<a href="https://docs.aws.amazon.com/zh_cn/cli/latest/userguide/cli-configure-quickstart.html">https://docs.aws.amazon.com/zh_cn/cli/latest/userguide/cli-configure-quickstart.html</a></p>

<h2 id="hello-world">Hello World</h2>

<p>开发环境都设置好了！</p>

<p>首先新建一个目录：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">mkdir </span>cdk-demo <span class="o">&amp;&amp;</span> <span class="nb">cd </span>cdk-demo
</code></pre></div></div>

<p>初始换项目，使用 typescipt 语言:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cdk init app <span class="nt">--language</span> typescript
</code></pre></div></div>

<ul>
  <li>选择 typescipt 语言，是因为 cdk 的文档最多最全的是 typescipt 语言，包括 api 和 示例。</li>
</ul>

<p>等若干分钟（会依赖您依赖包的下载速度）之后，打开 lib/cdk-workshop-stack.ts，默认示例代码可以看出，创建了一个 sqs 的 Queue 资源。</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="kd">class</span> <span class="nx">CdkWorkshopStack</span> <span class="kd">extends</span> <span class="nx">Stack</span> <span class="p">{</span>
  <span class="kd">constructor</span><span class="p">(</span><span class="nx">scope</span><span class="p">:</span> <span class="nx">Construct</span><span class="p">,</span> <span class="nx">id</span><span class="p">:</span> <span class="kr">string</span><span class="p">,</span> <span class="nx">props</span><span class="p">?:</span> <span class="nx">StackProps</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">super</span><span class="p">(</span><span class="nx">scope</span><span class="p">,</span> <span class="nx">id</span><span class="p">,</span> <span class="nx">props</span><span class="p">);</span>

    <span class="kd">const</span> <span class="nx">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">sqs</span><span class="p">.</span><span class="nx">Queue</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="dl">'</span><span class="s1">CdkWorkshopQueue</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span>
      <span class="na">visibilityTimeout</span><span class="p">:</span> <span class="nx">Duration</span><span class="p">.</span><span class="nx">seconds</span><span class="p">(</span><span class="mi">300</span><span class="p">)</span>
    <span class="p">});</span>

    <span class="kd">const</span> <span class="nx">topic</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">sns</span><span class="p">.</span><span class="nx">Topic</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="dl">'</span><span class="s1">CdkWorkshopTopic</span><span class="dl">'</span><span class="p">);</span>

    <span class="nx">topic</span><span class="p">.</span><span class="nx">addSubscription</span><span class="p">(</span><span class="k">new</span> <span class="nx">subs</span><span class="p">.</span><span class="nx">SqsSubscription</span><span class="p">(</span><span class="nx">queue</span><span class="p">));</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>对于新环境，需要运行:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cdk bootstrap
</code></pre></div></div>

<ul>
  <li>此命令在同一个账号和 region 中只需执行一次。</li>
</ul>

<p>通过 list 命令可以查看 stack。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cdk <span class="nb">ls</span>
</code></pre></div></div>

<p>运行部署：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cdk deploy
</code></pre></div></div>

<ul>
  <li>此命令执行后，会有资源改变列表，并询问是否确认部署。</li>
  <li>检查无误后，输入 y</li>
</ul>

<p>待执行完成后，检查是否真的创建出了 SQS 资源。</p>

<p>清理资源：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cdk destroy
</code></pre></div></div>

<p>验证完成之后，请及时使用 cdk destroy 清理资源，否则会<strong>产生费用</strong>。</p>

<p>使用 cdk destroy 删除更干净。</p>

<h2 id="关于渐进式">关于“渐进式”</h2>

<p>在本文的简介中，提出了 IaC/CDK 是“渐进式”的，这个主要是指 IaC 在执行的过程中，会存储当前执行的状态，并且能够回滚，叠加，删除。</p>

<p>而且在实际运行的过程中，我们也可以使用 “渐进式” 的模式来操作，特别是在测试某个安装的情况下，可以一步一步执行，当执行失败的时候不至于全部回滚。</p>

<p>比如，我们可以先创建一个 VPC：</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">const</span> <span class="nx">vpc</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Vpc</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="dl">'</span><span class="s1">EKSVpc</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span>
      <span class="na">ipAddresses</span><span class="p">:</span> <span class="nx">IpAddresses</span><span class="p">.</span><span class="nx">cidr</span><span class="p">(</span><span class="dl">'</span><span class="s1">10.10.0.0/16</span><span class="dl">'</span><span class="p">)</span>
    <span class="p">});</span>
</code></pre></div></div>

<p>此时 我们可以先执行这段程序:<code class="language-plaintext highlighter-rouge">cdk deploy</code>。</p>

<p>然后，我们加入新的代码，继续创建了一个 eks。</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">const</span> <span class="nx">vpc</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Vpc</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="dl">'</span><span class="s1">EKSVpc</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span>
      <span class="na">ipAddresses</span><span class="p">:</span> <span class="nx">IpAddresses</span><span class="p">.</span><span class="nx">cidr</span><span class="p">(</span><span class="dl">'</span><span class="s1">10.10.0.0/16</span><span class="dl">'</span><span class="p">)</span>
    <span class="p">});</span>
    <span class="kd">const</span> <span class="nx">eksCluster</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Cluster</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="dl">'</span><span class="s1">EKSCluster</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span>
      <span class="na">clusterName</span><span class="p">:</span> <span class="dl">"</span><span class="s2">cdk-workshop</span><span class="dl">"</span><span class="p">,</span>
      <span class="nx">vpc</span><span class="p">,</span>
      <span class="na">albController</span><span class="p">:</span> <span class="p">{</span>
        <span class="na">version</span><span class="p">:</span> <span class="nx">AlbControllerVersion</span><span class="p">.</span><span class="nx">V2_4_1</span><span class="p">,</span>
      <span class="p">},</span>
      <span class="na">defaultCapacity</span><span class="p">:</span> <span class="mi">1</span>
    <span class="p">});</span>
</code></pre></div></div>

<p>然后继续执行 <code class="language-plaintext highlighter-rouge">cdk deploy</code>，此时执行引擎会去比较当前的资源描述和当前 state 的异同，并开始创建 eks。</p>

<p>如果 eks 创建失败，整个过程会回滚，此时状态会回滚到 eks 创建之前，也就是说 vpc 还在。</p>

<p>同理，如果想要删除 eks，只需要删除相应的 eks resource 代码即可。</p>]]></content><author><name>啤酒云</name></author><category term="iac," /><category term="aws" /><category term="cdk" /><summary type="html"><![CDATA[本文是 AWS CDK 入门教程，将利用 “渐进” 模式 使用 AWS CDK 生产一个生产可用的 EKS 集群。本文是上半部分，CDK 入门知识。]]></summary></entry></feed>